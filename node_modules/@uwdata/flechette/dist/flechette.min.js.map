{"version":3,"file":"flechette.min.js","sources":["../src/constants.js","../src/util/arrays.js","../src/util/objects.js","../src/data-types.js","../src/util/numbers.js","../src/util/strings.js","../src/util/read.js","../src/util/struct.js","../src/batch.js","../src/column.js","../src/table.js","../src/batch-type.js","../src/encode/builder.js","../src/compression.js","../src/decode/block.js","../src/decode/body-compression.js","../src/decode/record-batch.js","../src/decode/dictionary-batch.js","../src/decode/data-type.js","../src/decode/metadata.js","../src/decode/schema.js","../src/decode/message.js","../src/decode/decode-ipc.js","../src/decode/table-from-ipc.js","../src/encode/record-batch.js","../src/encode/dictionary-batch.js","../src/encode/metadata.js","../src/encode/data-type.js","../src/encode/schema.js","../src/encode/footer.js","../src/encode/message.js","../src/encode/sink.js","../src/encode/encode-ipc.js","../src/encode/table-to-ipc.js","../src/build/buffer.js","../src/build/builders/batch.js","../src/build/builders/validity.js","../src/build/builders/dictionary.js","../src/build/infer-type.js","../src/build/builders/binary.js","../src/build/builders/bool.js","../src/build/builders/decimal.js","../src/build/builders/fixed-size-binary.js","../src/build/builders/fixed-size-list.js","../src/build/builders/interval.js","../src/build/builders/list.js","../src/build/builders/struct.js","../src/build/builders/map.js","../src/build/builders/run-end-encoded.js","../src/build/builders/union.js","../src/build/builders/utf8.js","../src/build/builders/values.js","../src/build/builder.js","../src/build/column-from-values.js","../src/build/column-from-array.js","../src/build/table-from-columns.js","../src/build/table-from-arrays.js"],"sourcesContent":["/** Magic bytes 'ARROW1' indicating the Arrow 'file' format. */\nexport const MAGIC = Uint8Array.of(65, 82, 82, 79, 87, 49);\n\n/** Bytes for an 'end of stream' message. */\nexport const EOS = Uint8Array.of(255, 255, 255, 255, 0, 0, 0, 0);\n\n/**\n * Apache Arrow version.\n */\nexport const Version = /** @type {const} */ ({\n  /** 0.1.0 (October 2016). */\n  V1: 0,\n  /** 0.2.0 (February 2017). Non-backwards compatible with V1. */\n  V2: 1,\n  /** 0.3.0 -> 0.7.1 (May - December 2017). Non-backwards compatible with V2. */\n  V3: 2,\n  /** >= 0.8.0 (December 2017). Non-backwards compatible with V3. */\n  V4: 3,\n  /**\n   * >= 1.0.0 (July 2020). Backwards compatible with V4 (V5 readers can read V4\n   * metadata and IPC messages). Implementations are recommended to provide a\n   * V4 compatibility mode with V5 format changes disabled.\n   *\n   * Incompatible changes between V4 and V5:\n   * - Union buffer layout has changed.\n   *   In V5, Unions don't have a validity bitmap buffer.\n   */\n  V5: 4\n});\n\n/**\n * Endianness of Arrow-encoded data.\n */\nexport const Endianness = /** @type {const} */ ({\n  Little: 0,\n  Big: 1\n});\n\n/**\n * Message header type codes.\n */\nexport const MessageHeader = /** @type {const} */ ({\n  NONE: 0,\n  /**\n   * A Schema describes the columns in a record batch.\n   */\n  Schema: 1,\n  /**\n   * For sending dictionary encoding information. Any Field can be\n   * dictionary-encoded, but in this case none of its children may be\n   * dictionary-encoded.\n   * There is one vector / column per dictionary, but that vector / column\n   * may be spread across multiple dictionary batches by using the isDelta\n   * flag.\n   */\n  DictionaryBatch: 2,\n  /**\n   * A data header describing the shared memory layout of a \"record\" or \"row\"\n   * batch. Some systems call this a \"row batch\" internally and others a \"record\n   * batch\".\n   */\n  RecordBatch: 3,\n  /**\n   * EXPERIMENTAL: Metadata for n-dimensional arrays, aka \"tensors\" or\n   * \"ndarrays\". Arrow implementations in general are not required to implement\n   * this type.\n   *\n   * Not currently supported by Flechette.\n   */\n  Tensor: 4,\n  /**\n   * EXPERIMENTAL: Metadata for n-dimensional sparse arrays, aka \"sparse\n   * tensors\". Arrow implementations in general are not required to implement\n   * this type.\n   *\n   * Not currently supported by Flechette.\n   */\n  SparseTensor: 5\n});\n\n/**\n * Field data type ids.\n * Only non-negative values ever occur in IPC flatbuffer binary data.\n */\nexport const Type = /** @type {const} */ ({\n  /**\n   * Dictionary types compress data by using a set of integer indices to\n   * lookup potentially repeated vales in a separate dictionary of values.\n   *\n   * This type entry is provided for API convenience, it does not occur\n   * in actual Arrow IPC binary data.\n   */\n  Dictionary: -1,\n  /** No data type. Included for flatbuffer compatibility. */\n  NONE: 0,\n  /** Null values only. */\n  Null: 1,\n  /** Integers, either signed or unsigned, with 8, 16, 32, or 64 bit widths. */\n  Int: 2,\n  /** Floating point numbers with 16, 32, or 64 bit precision. */\n  Float: 3,\n  /** Opaque binary data. */\n  Binary: 4,\n  /** Unicode with UTF-8 encoding. */\n  Utf8: 5,\n  /** Booleans represented as 8 bit bytes. */\n  Bool: 6,\n  /**\n   * Exact decimal value represented as an integer value in two's complement.\n   * Currently only 128-bit (16-byte) and 256-bit (32-byte) integers are used.\n   * The representation uses the endianness indicated in the schema.\n   */\n  Decimal: 7,\n  /**\n   * Date is either a 32-bit or 64-bit signed integer type representing an\n   * elapsed time since UNIX epoch (1970-01-01), stored in either of two units:\n   * - Milliseconds (64 bits) indicating UNIX time elapsed since the epoch (no\n   * leap seconds), where the values are evenly divisible by 86400000\n   * - Days (32 bits) since the UNIX epoch\n   */\n  Date: 8,\n  /**\n   * Time is either a 32-bit or 64-bit signed integer type representing an\n   * elapsed time since midnight, stored in either of four units: seconds,\n   * milliseconds, microseconds or nanoseconds.\n   *\n   * The integer `bitWidth` depends on the `unit` and must be one of the following:\n   * - SECOND and MILLISECOND: 32 bits\n   * - MICROSECOND and NANOSECOND: 64 bits\n   *\n   * The allowed values are between 0 (inclusive) and 86400 (=24*60*60) seconds\n   * (exclusive), adjusted for the time unit (for example, up to 86400000\n   * exclusive for the MILLISECOND unit).\n   * This definition doesn't allow for leap seconds. Time values from\n   * measurements with leap seconds will need to be corrected when ingesting\n   * into Arrow (for example by replacing the value 86400 with 86399).\n   */\n  Time: 9,\n  /**\n   * Timestamp is a 64-bit signed integer representing an elapsed time since a\n   * fixed epoch, stored in either of four units: seconds, milliseconds,\n   * microseconds or nanoseconds, and is optionally annotated with a timezone.\n   *\n   * Timestamp values do not include any leap seconds (in other words, all\n   * days are considered 86400 seconds long).\n   *\n   * The timezone is an optional string for the name of a timezone, one of:\n   *\n   *  - As used in the Olson timezone database (the \"tz database\" or\n   *    \"tzdata\"), such as \"America/New_York\".\n   *  - An absolute timezone offset of the form \"+XX:XX\" or \"-XX:XX\",\n   *    such as \"+07:30\".\n   *\n   * Whether a timezone string is present indicates different semantics about\n   * the data.\n   */\n  Timestamp: 10,\n  /**\n   * A \"calendar\" interval which models types that don't necessarily\n   * have a precise duration without the context of a base timestamp (e.g.\n   * days can differ in length during day light savings time transitions).\n   * All integers in the units below are stored in the endianness indicated\n   * by the schema.\n   *\n   *  - YEAR_MONTH - Indicates the number of elapsed whole months, stored as\n   *    4-byte signed integers.\n   *  - DAY_TIME - Indicates the number of elapsed days and milliseconds (no\n   *    leap seconds), stored as 2 contiguous 32-bit signed integers (8-bytes\n   *    in total). Support of this IntervalUnit is not required for full arrow\n   *    compatibility.\n   *  - MONTH_DAY_NANO - A triple of the number of elapsed months, days, and\n   *    nanoseconds. The values are stored contiguously in 16-byte blocks.\n   *    Months and days are encoded as 32-bit signed integers and nanoseconds\n   *    is encoded as a 64-bit signed integer. Nanoseconds does not allow for\n   *    leap seconds. Each field is independent (e.g. there is no constraint\n   *    that nanoseconds have the same sign as days or that the quantity of\n   *    nanoseconds represents less than a day's worth of time).\n   */\n  Interval: 11,\n  /**\n   * List (vector) data supporting variably-sized lists.\n   * A list has a single child data type for list entries.\n   */\n  List: 12,\n  /**\n   * A struct consisting of multiple named child data types.\n   */\n  Struct: 13,\n  /**\n   * A union is a complex type with parallel child data types. By default ids\n   * in the type vector refer to the offsets in the children. Optionally\n   * typeIds provides an indirection between the child offset and the type id.\n   * For each child `typeIds[offset]` is the id used in the type vector.\n   */\n  Union: 14,\n  /**\n   * Binary data where each entry has the same fixed size.\n   */\n  FixedSizeBinary: 15,\n  /**\n   * List (vector) data where every list has the same fixed size.\n   * A list has a single child data type for list entries.\n   */\n  FixedSizeList: 16,\n  /**\n   * A Map is a logical nested type that is represented as\n   * List<entries: Struct<key: K, value: V>>\n   *\n   * In this layout, the keys and values are each respectively contiguous. We do\n   * not constrain the key and value types, so the application is responsible\n   * for ensuring that the keys are hashable and unique. Whether the keys are sorted\n   * may be set in the metadata for this field.\n   *\n   * In a field with Map type, the field has a child Struct field, which then\n   * has two children: key type and the second the value type. The names of the\n   * child fields may be respectively \"entries\", \"key\", and \"value\", but this is\n   * not enforced.\n   *\n   * Map\n   * ```text\n   *   - child[0] entries: Struct\n   *   - child[0] key: K\n   *   - child[1] value: V\n   *  ```\n   * Neither the \"entries\" field nor the \"key\" field may be nullable.\n   *\n   * The metadata is structured so that Arrow systems without special handling\n   * for Map can make Map an alias for List. The \"layout\" attribute for the Map\n   * field must have the same contents as a List.\n   */\n  Map: 17,\n  /**\n   * An absolute length of time unrelated to any calendar artifacts. For the\n   * purposes of Arrow implementations, adding this value to a Timestamp\n   * (\"t1\") naively (i.e. simply summing the two numbers) is acceptable even\n   * though in some cases the resulting Timestamp (t2) would not account for\n   * leap-seconds during the elapsed time between \"t1\" and \"t2\". Similarly,\n   * representing the difference between two Unix timestamp is acceptable, but\n   * would yield a value that is possibly a few seconds off from the true\n   * elapsed time.\n   *\n   * The resolution defaults to millisecond, but can be any of the other\n   * supported TimeUnit values as with Timestamp and Time types. This type is\n   * always represented as an 8-byte integer.\n   */\n  Duration: 18,\n  /**\n   * Same as Binary, but with 64-bit offsets, allowing representation of\n   * extremely large data values.\n   */\n  LargeBinary: 19,\n  /**\n   * Same as Utf8, but with 64-bit offsets, allowing representation of\n   * extremely large data values.\n   */\n  LargeUtf8: 20,\n  /**\n   * Same as List, but with 64-bit offsets, allowing representation of\n   * extremely large data values.\n   */\n  LargeList: 21,\n  /**\n   * Contains two child arrays, run_ends and values. The run_ends child array\n   * must be a 16/32/64-bit integer array which encodes the indices at which\n   * the run with the value in each corresponding index in the values child\n   * array ends. Like list/struct types, the value array can be of any type.\n   */\n  RunEndEncoded: 22,\n  /**\n   * Logically the same as Binary, but the internal representation uses a view\n   * struct that contains the string length and either the string's entire data\n   * inline (for small strings) or an inlined prefix, an index of another buffer,\n   * and an offset pointing to a slice in that buffer (for non-small strings).\n   *\n   * Since it uses a variable number of data buffers, each Field with this type\n   * must have a corresponding entry in `variadicBufferCounts`.\n   */\n  BinaryView: 23,\n  /**\n   * Logically the same as Utf8, but the internal representation uses a view\n   * struct that contains the string length and either the string's entire data\n   * inline (for small strings) or an inlined prefix, an index of another buffer,\n   * and an offset pointing to a slice in that buffer (for non-small strings).\n   *\n   * Since it uses a variable number of data buffers, each Field with this type\n   * must have a corresponding entry in `variadicBufferCounts`.\n   */\n  Utf8View: 24,\n  /**\n   * Represents the same logical types that List can, but contains offsets and\n   * sizes allowing for writes in any order and sharing of child values among\n   * list values.\n   */\n  ListView: 25,\n  /**\n   * Same as ListView, but with 64-bit offsets and sizes, allowing to represent\n   * extremely large data values.\n   */\n  LargeListView: 26\n});\n\n/**\n * Floating point number precision.\n */\nexport const Precision = /** @type {const} */ ({\n  /** 16-bit floating point number. */\n  HALF: 0,\n  /** 32-bit floating point number. */\n  SINGLE: 1,\n  /** 64-bit floating point number. */\n  DOUBLE: 2\n});\n\n/**\n * Date units.\n */\nexport const DateUnit = /** @type {const} */ ({\n  /* Days (as 32 bit int) since the UNIX epoch. */\n  DAY: 0,\n  /**\n   * Milliseconds (as 64 bit int) indicating UNIX time elapsed since the epoch\n   * (no leap seconds), with values evenly divisible by 86400000.\n   */\n  MILLISECOND: 1\n});\n\n/**\n * Time units.\n */\nexport const TimeUnit = /** @type {const} */ ({\n  /** Seconds. */\n  SECOND: 0,\n  /** Milliseconds. */\n  MILLISECOND: 1,\n  /** Microseconds. */\n  MICROSECOND: 2,\n  /** Nanoseconds. */\n  NANOSECOND: 3\n});\n\n/**\n * Date/time interval units.\n */\nexport const IntervalUnit = /** @type {const} */ ({\n  /**\n   * Indicates the number of elapsed whole months, stored as 4-byte signed\n   * integers.\n   */\n  YEAR_MONTH: 0,\n  /**\n   * Indicates the number of elapsed days and milliseconds (no leap seconds),\n   * stored as 2 contiguous 32-bit signed integers (8-bytes in total). Support\n   * of this IntervalUnit is not required for full arrow compatibility.\n   */\n  DAY_TIME: 1,\n  /**\n   * A triple of the number of elapsed months, days, and nanoseconds.\n   * The values are stored contiguously in 16-byte blocks. Months and days are\n   * encoded as 32-bit signed integers and nanoseconds is encoded as a 64-bit\n   * signed integer. Nanoseconds does not allow for leap seconds. Each field is\n   * independent (e.g. there is no constraint that nanoseconds have the same\n   * sign as days or that the quantity of nanoseconds represents less than a\n   * day's worth of time).\n   */\n  MONTH_DAY_NANO: 2\n});\n\n/**\n * Union type modes.\n */\nexport const UnionMode = /** @type {const} */ ({\n  /** Sparse union layout with full arrays for each sub-type. */\n  Sparse: 0,\n  /** Dense union layout with offsets into value arrays. */\n  Dense: 1\n});\n\n/**\n * Compression types.\n */\nexport const CompressionType = /** @type {const} */ ({\n  /**\n   * LZ4 frame compression.\n   * Not to be confused with \"raw\" (also called \"block\") format.\n   */\n  LZ4_FRAME: 0,\n  /** Zstandard compression. */\n  ZSTD: 1\n});\n\n/**\n * Body compression methods.\n * Provided for forward compatibility in case Arrow needs to support\n * different strategies for compressing the IPC message body (like\n * whole-body compression rather than buffer-level) in the future.\n */\nexport const BodyCompressionMethod = /** @type {const} */ ({\n  /**\n   * Each constituent buffer is first compressed with the indicated\n   * compressor, and then written with the uncompressed length in the first 8\n   * bytes as a 64-bit little-endian signed integer followed by the compressed\n   * buffer bytes (and then padding as required by the protocol). The\n   * uncompressed length may be set to -1 to indicate that the data that\n   * follows is not compressed, which can be useful for cases where\n   * compression does not yield appreciable savings.\n   */\n  BUFFER: 0\n});\n","/**\n * @import { Int64ArrayConstructor, IntArrayConstructor, IntegerArray, TypedArray } from '../types.js'\n */\nexport const uint8Array = Uint8Array;\nexport const uint16Array = Uint16Array;\nexport const uint32Array = Uint32Array;\nexport const uint64Array = BigUint64Array;\nexport const int8Array = Int8Array;\nexport const int16Array = Int16Array;\nexport const int32Array = Int32Array;\nexport const int64Array = BigInt64Array;\nexport const float32Array = Float32Array;\nexport const float64Array = Float64Array;\n\n/**\n * Check if an input value is an ArrayBuffer or SharedArrayBuffer.\n * @param {unknown} data\n * @returns {data is ArrayBufferLike}\n */\nexport function isArrayBufferLike(data) {\n  return data instanceof ArrayBuffer || (\n    typeof SharedArrayBuffer !== 'undefined' &&\n    data instanceof SharedArrayBuffer\n  );\n}\n\n/**\n * Return the appropriate typed array constructor for the given\n * integer type metadata.\n * @param {number} bitWidth The integer size in bits.\n * @param {boolean} signed Flag indicating if the integer is signed.\n * @returns {IntArrayConstructor}\n */\nexport function intArrayType(bitWidth, signed) {\n  const i = Math.log2(bitWidth) - 3;\n  return (\n    signed\n      ? [int8Array, int16Array, int32Array, int64Array]\n      : [uint8Array, uint16Array, uint32Array, uint64Array]\n  )[i];\n}\n\n/** Shared prototype for typed arrays. */\nconst TypedArray = Object.getPrototypeOf(Int8Array);\n\n/**\n * Check if a value is a typed array.\n * @param {*} value The value to check.\n * @returns {value is TypedArray}\n *  True if value is a typed array, false otherwise.\n */\nexport function isTypedArray(value) {\n  return value instanceof TypedArray;\n}\n\n/**\n * Check if a value is either a standard array or typed array.\n * @param {*} value The value to check.\n * @returns {value is (Array | TypedArray)}\n *  True if value is an array, false otherwise.\n */\nexport function isArray(value) {\n  return Array.isArray(value) || isTypedArray(value);\n}\n\n/**\n * Check if a value is an array type (constructor) for 64-bit integers,\n * one of BigInt64Array or BigUint64Array.\n * @param {*} value The value to check.\n * @returns {value is Int64ArrayConstructor}\n *  True if value is a 64-bit array type, false otherwise.\n */\nexport function isInt64ArrayType(value) {\n  return value === int64Array || value === uint64Array;\n}\n\n/**\n * Determine the correct index into an offset array for a given\n * full column row index. Assumes offset indices can be manipulated\n * as 32-bit signed integers.\n * @param {IntegerArray} offsets The offsets array.\n * @param {number} index The full column row index.\n */\nexport function bisect(offsets, index) {\n  let a = 0;\n  let b = offsets.length;\n  if (b <= 2147483648) { // 2 ** 31\n    // fast version, use unsigned bit shift\n    // array length fits within 32-bit signed integer\n    do {\n      const mid = (a + b) >>> 1;\n      if (offsets[mid] <= index) a = mid + 1;\n      else b = mid;\n    } while (a < b);\n  } else {\n    // slow version, use division and truncate\n    // array length exceeds 32-bit signed integer\n    do {\n      const mid = Math.trunc((a + b) / 2);\n      if (offsets[mid] <= index) a = mid + 1;\n      else b = mid;\n    } while (a < b);\n  }\n  return a;\n}\n\n/**\n * Compute a 64-bit aligned buffer size.\n * @param {number} length The starting size.\n * @param {number} bpe Bytes per element.\n * @returns {number} The aligned size.\n */\nfunction align64(length, bpe = 1) {\n  return (((length * bpe) + 7) & ~7) / bpe;\n}\n\n/**\n * Return a 64-bit aligned version of the array.\n * @template {TypedArray} T\n * @param {T} array The array.\n * @param {number} length The current array length.\n * @returns {T} The aligned array.\n */\nexport function align(array, length = array.length) {\n  const alignedLength = align64(length, array.BYTES_PER_ELEMENT);\n  return array.length > alignedLength ? /** @type {T} */ (array.subarray(0, alignedLength))\n    : array.length < alignedLength ? resize(array, alignedLength)\n    : array;\n}\n\n/**\n * Resize a typed array to exactly the specified length.\n * @template {TypedArray} T\n * @param {T} array The array.\n * @param {number} newLength The new length.\n * @param {number} [offset] The offset at which to copy the old array.\n * @returns {T} The resized array.\n */\nexport function resize(array, newLength, offset = 0) {\n  // @ts-ignore\n  const newArray = new array.constructor(newLength);\n  newArray.set(array, offset);\n  return newArray;\n}\n\n/**\n * Grow a typed array to accommdate a minimum index. The array size is\n * doubled until it exceeds the minimum index.\n * @template {TypedArray} T\n * @param {T} array The array.\n * @param {number} index The minimum index.\n * @param {boolean} [shift] Flag to shift copied bytes to back of array.\n * @returns {T} The resized array.\n */\nexport function grow(array, index, shift) {\n  while (array.length <= index) {\n    array = resize(array, array.length << 1, shift ? array.length : 0);\n  }\n  return array;\n}\n","/**\n * Check if a value is a Date instance\n * @param {*} value The value to check.\n * @returns {value is Date} True if value is a Date, false otherwise.\n */\nexport function isDate(value) {\n  return value instanceof Date;\n}\n\n/**\n * Check if a value is iterable.\n * @param {*} value The value to check.\n * @returns {value is Iterable} True if value is iterable, false otherwise.\n */\nexport function isIterable(value) {\n  return typeof value[Symbol.iterator] === 'function';\n}\n\n/**\n * Return the input value if it passes a test.\n * Otherwise throw an error using the given message generator.\n * @template T\n * @param {T} value The value to check.\n * @param {(value: T) => boolean} test The test function.\n * @param {(value: *) => string} message Message generator.\n * @returns {T} The input value.\n * @throws if the value does not pass the test\n */\nexport function check(value, test, message) {\n  if (test(value)) return value;\n  throw new Error(message(value));\n}\n\n/**\n * Return the input value if it exists in the provided set.\n * Otherwise throw an error using the given message generator.\n * @template T\n * @param {T} value The value to check.\n * @param {T[] | Record<string,T>} set The set of valid values.\n * @param {(value: *) => string} [message] Message generator.\n * @returns {T} The input value.\n * @throws if the value is not included in the set\n */\nexport function checkOneOf(value, set, message) {\n  set = Array.isArray(set) ? set : Object.values(set);\n  return check(\n    value,\n    (value) => set.includes(value),\n    message ?? (() => `${value} must be one of ${set}`)\n  );\n}\n\n/**\n * Return the first object key that pairs with the given value.\n * @param {Record<string,any>} object The object to search.\n * @param {any} value The value to lookup.\n * @returns {string} The first matching key, or '<Unknown>' if not found.\n */\nexport function keyFor(object, value) {\n  for (const [key, val] of Object.entries(object)) {\n    if (val === value) return key;\n  }\n  return '<Unknown>';\n}\n","/**\n * @import { BinaryType, BinaryViewType, BoolType, DataType, DateType, DateUnit_, DecimalType, DictionaryType, DurationType, Field, FixedSizeBinaryType, FixedSizeListType, FloatType, IntBitWidth, IntervalType, IntervalUnit_, IntType, LargeBinaryType, LargeListType, LargeListViewType, LargeUtf8Type, ListType, ListViewType, MapType, NullType, Precision_, RunEndEncodedType, StructType, TimestampType, TimeType, TimeUnit_, UnionMode_, UnionType, Utf8Type, Utf8ViewType } from './types.js'\n */\nimport { DateUnit, IntervalUnit, Precision, TimeUnit, Type, UnionMode } from './constants.js';\nimport { intArrayType, float32Array, float64Array, int32Array, int64Array, uint16Array, uint64Array } from './util/arrays.js';\nimport { check, checkOneOf, keyFor } from './util/objects.js';\n\n/**\n * @typedef {Field | DataType} FieldInput\n */\n\nexport const invalidDataType = (typeId) =>\n  `Unsupported data type: \"${keyFor(Type, typeId)}\" (id ${typeId})`;\n\n/**\n * Return a new field instance for use in a schema or type definition. A field\n * represents a field name, data type, and additional metadata. Fields are used\n * to represent child types within nested types like List, Struct, and Union.\n * @param {string} name The field name.\n * @param {DataType} type The field data type.\n * @param {boolean} [nullable=true] Flag indicating if the field is nullable\n *  (default `true`).\n * @param {Map<string,string>|null} [metadata=null] Custom field metadata\n *  annotations (default `null`).\n * @returns {Field} The field instance.\n */\nexport const field = (name, type, nullable = true, metadata = null) => ({\n  name,\n  type,\n  nullable,\n  metadata\n});\n\n/**\n * Checks if a value is a field instance.\n * @param {any} value\n * @returns {value is Field}\n */\nfunction isField(value) {\n  return Object.hasOwn(value, 'name') && isDataType(value.type)\n}\n\n/**\n * Checks if a value is a data type instance.\n * @param {any} value\n * @returns {value is DataType}\n */\nfunction isDataType(value) {\n  return typeof value?.typeId === 'number';\n}\n\n/**\n * Return a field instance from a field or data type input.\n * @param {FieldInput} value\n *  The value to map to a field.\n * @param {string} [defaultName] The default field name.\n * @param {boolean} [defaultNullable=true] The default nullable value.\n * @returns {Field} The field instance.\n */\nfunction asField(value, defaultName = '', defaultNullable = true) {\n  return isField(value)\n    ? value\n    : field(\n        defaultName,\n        check(value, isDataType, () => `Data type expected.`),\n        defaultNullable\n      );\n}\n\n/////\n\n/**\n * Return a basic type with only a type id.\n * @template {typeof Type[keyof typeof Type]} T\n * @param {T} typeId The type id.\n */\nconst basicType = (typeId) => ({ typeId });\n\n/**\n * Return a Dictionary data type instance.  A dictionary type consists of a\n * dictionary of values (which may be of any type) and corresponding integer\n * indices that reference those values. If values are repeated, a dictionary\n * encoding can provide substantial space savings. In the IPC format,\n * dictionary indices reside alongside other columns in a record batch, while\n * dictionary values are written to special dictionary batches, linked by a\n * unique dictionary *id*.\n * @param {DataType} type The data type of dictionary\n *  values.\n * @param {IntType} [indexType] The data type of\n *  dictionary indices. Must be an integer type (default `int32`).\n * @param {boolean} [ordered=false] Indicates if dictionary values are\n *  ordered (default `false`).\n * @param {number} [id=-1] The dictionary id. The default value (-1) indicates\n *  the dictionary applies to a single column only. Provide an explicit id in\n *  order to reuse a dictionary across columns when building, in which case\n *  different dictionaries *must* have different unique ids. All dictionary\n *  ids are later resolved (possibly to new values) upon IPC encoding.\n * @returns {DictionaryType}\n */\nexport const dictionary = (type, indexType, ordered = false, id = -1) => ({\n  typeId: Type.Dictionary,\n  id,\n  dictionary: type,\n  indices: indexType || int32(),\n  ordered\n});\n\n/**\n * Return a Null data type instance. Null data requires no storage and all\n * extracted values are `null`.\n * @returns {NullType} The null data type.\n */\nexport const nullType = () => basicType(Type.Null);\n\n/**\n * Return an Int data type instance.\n * @param {IntBitWidth} [bitWidth=32] The integer bit width.\n *  One of `8`, `16`, `32` (default), or `64`.\n * @param {boolean} [signed=true] Flag for signed or unsigned integers\n *  (default `true`).\n * @returns {IntType} The integer data type.\n */\nexport const int = (bitWidth = 32, signed = true) => ({\n  typeId: Type.Int,\n  bitWidth: checkOneOf(bitWidth, [8, 16, 32, 64]),\n  signed,\n  values: intArrayType(bitWidth, signed)\n});\n/**\n * Return an Int data type instance for 8 bit signed integers.\n * @returns {IntType} The integer data type.\n */\nexport const int8 = () => int(8);\n/**\n * Return an Int data type instance for 16 bit signed integers.\n * @returns {IntType} The integer data type.\n */\nexport const int16 = () => int(16);\n/**\n * Return an Int data type instance for 32 bit signed integers.\n * @returns {IntType} The integer data type.\n */\nexport const int32 = () => int(32);\n/**\n * Return an Int data type instance for 64 bit signed integers.\n * @returns {IntType} The integer data type.\n */\nexport const int64 = () => int(64);\n/**\n * Return an Int data type instance for 8 bit unsigned integers.\n * @returns {IntType} The integer data type.\n */\nexport const uint8 = () => int(8, false);\n/**\n * Return an Int data type instance for 16 bit unsigned integers.\n * @returns {IntType} The integer data type.\n */\nexport const uint16 = () => int(16, false);\n/**\n * Return an Int data type instance for 32 bit unsigned integers.\n * @returns {IntType} The integer data type.\n */\nexport const uint32 = () => int(32, false);\n/**\n * Return an Int data type instance for 64 bit unsigned integers.\n * @returns {IntType} The integer data type.\n */\nexport const uint64 = () => int(64, false);\n\n/**\n * Return a Float data type instance for floating point numbers.\n * @param {Precision_} [precision=2] The floating point\n *  precision. One of `Precision.HALF` (16-bit), `Precision.SINGLE` (32-bit)\n *  or `Precision.DOUBLE` (64-bit, default).\n * @returns {FloatType} The floating point data type.\n */\nexport const float = (precision = 2) => ({\n  typeId: Type.Float,\n  precision: checkOneOf(precision, Precision),\n  values: [uint16Array, float32Array, float64Array][precision]\n});\n/**\n * Return a Float data type instance for half-precision (16 bit) numbers.\n * @returns {FloatType} The floating point data type.\n */\nexport const float16 = () => float(Precision.HALF);\n/**\n * Return a Float data type instance for single-precision (32 bit) numbers.\n * @returns {FloatType} The floating point data type.\n */\nexport const float32 = () => float(Precision.SINGLE);\n/**\n * Return a Float data type instance for double-precision (64 bit) numbers.\n * @returns {FloatType} The floating point data type.\n */\nexport const float64 = () => float(Precision.DOUBLE);\n\n/**\n * Return a Binary data type instance for variably-sized opaque binary data\n * with 32-bit offsets.\n * @returns {BinaryType} The binary data type.\n */\nexport const binary = () => ({\n  typeId: Type.Binary,\n  offsets: int32Array\n});\n\n/**\n * Return a Utf8 data type instance for Unicode string data.\n * [UTF-8](https://en.wikipedia.org/wiki/UTF-8) code points are stored as\n * binary data.\n * @returns {Utf8Type} The utf8 data type.\n */\nexport const utf8 = () => ({\n  typeId: Type.Utf8,\n  offsets: int32Array\n});\n\n/**\n * Return a Bool data type instance. Bool values are stored compactly in\n * bitmaps with eight values per byte.\n * @returns {BoolType} The bool data type.\n */\nexport const bool = () => basicType(Type.Bool);\n\n/**\n * Return a Decimal data type instance. Decimal values are represented as 32,\n * 64, 128, or 256 bit integers in two's complement. Decimals are fixed point\n * numbers with a set *precision* (total number of decimal digits) and *scale*\n * (number of fractional digits). For example, the number `35.42` can be\n * represented as `3542` with *precision* â‰¥ 4 and *scale* = 2.\n * @param {number} precision The decimal precision: the total number of\n *  decimal digits that can be represented.\n * @param {number} scale The number of fractional digits, beyond the\n *  decimal point.\n * @param {32 | 64 | 128 | 256} [bitWidth] The decimal bit width.\n *  One of 32, 64, 128 (default), or 256.\n * @returns {DecimalType} The decimal data type.\n */\nexport const decimal = (precision, scale, bitWidth = 128) => ({\n  typeId: Type.Decimal,\n  precision,\n  scale,\n  bitWidth: checkOneOf(bitWidth, [32, 64, 128, 256]),\n  values: bitWidth === 32 ? int32Array : uint64Array\n});\n/**\n * Return an Decimal data type instance with a bit width of 32.\n * @param {number} precision The decimal precision: the total number of\n *  decimal digits that can be represented.\n * @param {number} scale The number of fractional digits, beyond the\n *  decimal point.\n * @returns {DecimalType} The decimal data type.\n */\nexport const decimal32 = (precision, scale) => decimal(precision, scale, 32);\n/**\n * Return an Decimal data type instance with a bit width of 64.\n * @param {number} precision The decimal precision: the total number of\n *  decimal digits that can be represented.\n * @param {number} scale The number of fractional digits, beyond the\n *  decimal point.\n * @returns {DecimalType} The decimal data type.\n */\nexport const decimal64 = (precision, scale) => decimal(precision, scale, 64);\n/**\n * Return an Decimal data type instance with a bit width of 128.\n * @param {number} precision The decimal precision: the total number of\n *  decimal digits that can be represented.\n * @param {number} scale The number of fractional digits, beyond the\n *  decimal point.\n * @returns {DecimalType} The decimal data type.\n */\nexport const decimal128 = (precision, scale) => decimal(precision, scale, 128);\n/**\n * Return an Decimal data type instance with a bit width of 256.\n * @param {number} precision The decimal precision: the total number of\n *  decimal digits that can be represented.\n * @param {number} scale The number of fractional digits, beyond the\n *  decimal point.\n * @returns {DecimalType} The decimal data type.\n */\nexport const decimal256 = (precision, scale) => decimal(precision, scale, 256);\n\n/**\n * Return a Date data type instance. Date values are 32-bit or 64-bit signed\n * integers representing elapsed time since the UNIX epoch (Jan 1, 1970 UTC),\n * either in units of days (32 bits) or milliseconds (64 bits, with values\n * evenly divisible by 86400000).\n * @param {DateUnit_} unit The date unit.\n *  One of `DateUnit.DAY` or `DateUnit.MILLISECOND`.\n * @returns {DateType} The date data type.\n */\nexport const date = (unit) => ({\n  typeId: Type.Date,\n  unit: checkOneOf(unit, DateUnit),\n  values: unit === DateUnit.DAY ? int32Array : int64Array\n});\n/**\n * Return a Date data type instance with units of days.\n * @returns {DateType} The date data type.\n */\nexport const dateDay = () => date(DateUnit.DAY);\n/**\n * Return a Date data type instance with units of milliseconds.\n * @returns {DateType} The date data type.\n */\nexport const dateMillisecond = () => date(DateUnit.MILLISECOND);\n\n/**\n * Return a Time data type instance, stored in one of four *unit*s: seconds,\n * milliseconds, microseconds or nanoseconds. The integer *bitWidth* is\n * inferred from the *unit* and is 32 bits for seconds and milliseconds or\n * 64 bits for microseconds and nanoseconds. The allowed values are between 0\n * (inclusive) and 86400 (=24*60*60) seconds (exclusive), adjusted for the\n * time unit (for example, up to 86400000 exclusive for the\n * `DateUnit.MILLISECOND` unit.\n *\n * This definition doesn't allow for leap seconds. Time values from\n * measurements with leap seconds will need to be corrected when ingesting\n * into Arrow (for example by replacing the value 86400 with 86399).\n * @param {TimeUnit_} unit The time unit.\n *  One of `TimeUnit.SECOND`, `TimeUnit.MILLISECOND` (default),\n *  `TimeUnit.MICROSECOND`, or `TimeUnit.NANOSECOND`.\n * @returns {TimeType} The time data type.\n */\nexport const time = (unit = TimeUnit.MILLISECOND) => {\n  unit = checkOneOf(unit, TimeUnit);\n  const bitWidth = unit === TimeUnit.SECOND || unit === TimeUnit.MILLISECOND ? 32 : 64;\n  return {\n    typeId: Type.Time,\n    unit,\n    bitWidth,\n    values: bitWidth === 32 ? int32Array : int64Array\n  };\n};\n/**\n * Return a Time data type instance, represented as seconds.\n * @returns {TimeType} The time data type.\n */\nexport const timeSecond = () => time(TimeUnit.SECOND);\n/**\n * Return a Time data type instance, represented as milliseconds.\n * @returns {TimeType} The time data type.\n */\nexport const timeMillisecond = () => time(TimeUnit.MILLISECOND);\n/**\n * Return a Time data type instance, represented as microseconds.\n * @returns {TimeType} The time data type.\n */\nexport const timeMicrosecond = () => time(TimeUnit.MICROSECOND);\n/**\n * Return a Time data type instance, represented as nanoseconds.\n * @returns {TimeType} The time data type.\n */\nexport const timeNanosecond = () => time(TimeUnit.NANOSECOND);\n\n/**\n * Return a Timestamp data type instance. Timestamp values are 64-bit signed\n * integers representing an elapsed time since a fixed epoch, stored in either\n * of four units: seconds, milliseconds, microseconds or nanoseconds, and are\n * optionally annotated with a timezone. Timestamp values do not include any\n * leap seconds (in other words, all days are considered 86400 seconds long).\n * @param {TimeUnit_} [unit] The time unit.\n *  One of `TimeUnit.SECOND`, `TimeUnit.MILLISECOND` (default),\n *  `TimeUnit.MICROSECOND`, or `TimeUnit.NANOSECOND`.\n * @param {string|null} [timezone=null] An optional string for the name of a\n *  timezone. If provided, the value should either be a string as used in the\n *  Olson timezone database (the \"tz database\" or \"tzdata\"), such as\n *  \"America/New_York\", or an absolute timezone offset of the form \"+XX:XX\" or\n *  \"-XX:XX\", such as \"+07:30\".Whether a timezone string is present indicates\n *  different semantics about the data.\n * @returns {TimestampType} The time data type.\n */\nexport const timestamp = (unit = TimeUnit.MILLISECOND, timezone = null) => ({\n  typeId: Type.Timestamp,\n  unit: checkOneOf(unit, TimeUnit),\n  timezone,\n  values: int64Array\n});\n\n/**\n * Return an Interval type instance. Values represent calendar intervals stored\n * as integers for each date part. The supported *unit*s are year/moth,\n * day/time, and month/day/nanosecond intervals.\n *\n * `IntervalUnit.YEAR_MONTH` indicates the number of elapsed whole months,\n * stored as 32-bit signed integers.\n *\n * `IntervalUnit.DAY_TIME` indicates the number of elapsed days and\n * milliseconds (no leap seconds), stored as 2 contiguous 32-bit signed\n * integers (8-bytes in total).\n *\n * `IntervalUnit.MONTH_DAY_NANO` is a triple of the number of elapsed months,\n * days, and nanoseconds. The values are stored contiguously in 16-byte blocks.\n * Months and days are encoded as 32-bit signed integers and nanoseconds is\n * encoded as a 64-bit signed integer. Nanoseconds does not allow for leap\n * seconds. Each field is independent (e.g. there is no constraint that\n * nanoseconds have the same sign as days or that the quantity of nanoseconds\n * represents less than a day's worth of time).\n * @param {IntervalUnit_} unit  The interval unit.\n *  One of `IntervalUnit.YEAR_MONTH`, `IntervalUnit.DAY_TIME`, or\n *  `IntervalUnit.MONTH_DAY_NANO` (default).\n * @returns {IntervalType} The interval data type.\n */\nexport const interval = (unit = IntervalUnit.MONTH_DAY_NANO) => ({\n  typeId: Type.Interval,\n  unit: checkOneOf(unit, IntervalUnit),\n  values: unit === IntervalUnit.MONTH_DAY_NANO ? undefined : int32Array\n});\n\n/**\n * Return a List data type instance, representing variably-sized lists\n * (arrays) with 32-bit offsets. A list has a single child data type for\n * list entries. Lists are represented using integer offsets that indicate\n * list extents within a single child array containing all list values.\n * @param {FieldInput} child The child (list item) field or data type.\n * @returns {ListType} The list data type.\n */\nexport const list = (child) => ({\n  typeId: Type.List,\n  children: [ asField(child) ],\n  offsets: int32Array\n});\n\n/**\n * Return a Struct data type instance. A struct consists of multiple named\n * child data types. Struct values are stored as parallel child batches, one\n * per child type, and extracted to standard JavaScript objects.\n * @param {Field[] | Record<string, DataType>} children\n *  An array of property fields, or an object mapping property names to data\n *  types. If an object, the instantiated fields are assumed to be nullable\n *  and have no metadata.\n * @returns {StructType} The struct data type.\n */\nexport const struct = (children) => ({\n  typeId: Type.Struct,\n  children: Array.isArray(children) && children.length > 0 && isField(children[0])\n    ? /** @type {Field[]} */ (children)\n    : Object.entries(children).map(([name, type]) => field(name, type))\n});\n\n/**\n * Return a Union type instance. A union is a complex type with parallel\n * *children* data types. Union values are stored in either a sparse\n * (`UnionMode.Sparse`) or dense (`UnionMode.Dense`) layout *mode*. In a\n * sparse layout, child types are stored in parallel arrays with the same\n * lengths, resulting in many unused, empty values. In a dense layout, child\n * types have variable lengths and an offsets array is used to index the\n * appropriate value.\n *\n * By default, ids in the type vector refer to the index in the children\n * array. Optionally, *typeIds* provide an indirection between the child\n * index and the type id. For each child, `typeIds[index]` is the id used\n * in the type vector. The *typeIdForValue* argument provides a lookup\n * function for mapping input data to the proper child type id, and is\n * required if using builder methods.\n * @param {UnionMode_} mode The union mode.\n *  One of `UnionMode.Sparse` or `UnionMode.Dense`.\n * @param {FieldInput[]} children The children fields or data types.\n *  Types are mapped to nullable fields with no metadata.\n * @param {number[]} [typeIds]  Children type ids, in the same order as the\n *  children types. Type ids provide a level of indirection over children\n *  types. If not provided, the children indices are used as the type ids.\n * @param {(value: any, index: number) => number} [typeIdForValue]\n *  A function that takes an arbitrary value and a row index and returns a\n *  correponding union type id. Required by builder methods.\n * @returns {UnionType} The union data type.\n */\nexport const union = (mode, children, typeIds, typeIdForValue) => {\n  typeIds ??= children.map((v, i) => i);\n  return {\n    typeId: Type.Union,\n    mode: checkOneOf(mode, UnionMode),\n    typeIds,\n    typeMap: typeIds.reduce((m, id, i) => ((m[id] = i), m), {}),\n    children: children.map((v, i) => asField(v, `_${i}`)),\n    typeIdForValue,\n    offsets: int32Array,\n  };\n};\n\n/**\n * Create a FixedSizeBinary data type instance for opaque binary data where\n * each entry has the same fixed size.\n * @param {number} stride The fixed size in bytes.\n * @returns {FixedSizeBinaryType} The fixed size binary data type.\n */\nexport const fixedSizeBinary = (stride) => ({\n  typeId: Type.FixedSizeBinary,\n  stride\n});\n\n/**\n * Return a FixedSizeList type instance for list (array) data where every list\n * has the same fixed size. A list has a single child data type for list\n * entries. Fixed size lists are represented as a single child array containing\n * all list values, indexed using the known stride.\n * @param {FieldInput} child The list item data type.\n * @param {number} stride The fixed list size.\n * @returns {FixedSizeListType} The fixed size list data type.\n */\nexport const fixedSizeList = (child, stride) => ({\n  typeId: Type.FixedSizeList,\n  stride,\n  children: [ asField(child) ]\n});\n\n/**\n * Internal method to create a Map type instance.\n * @param {boolean} keysSorted Flag indicating if the map keys are sorted.\n * @param {Field} child The child fields.\n * @returns {MapType} The map data type.\n */\nexport const mapType = (keysSorted, child) => ({\n  typeId: Type.Map,\n  keysSorted,\n  children: [child],\n  offsets: int32Array\n});\n\n/**\n * Return a Map data type instance representing collections of key-value pairs.\n * A Map is a logical nested type that is represented as a list of key-value\n * structs. The key and value types are not constrained, so the application is\n * responsible for ensuring that the keys are hashable and unique, and that\n * keys are properly sorted if *keysSorted* is `true`.\n * @param {FieldInput} keyField The map key field or data type.\n * @param {FieldInput} valueField The map value field or data type.\n * @param {boolean} [keysSorted=false] Flag indicating if the map keys are\n *  sorted (default `false`).\n * @returns {MapType} The map data type.\n */\nexport const map = (keyField, valueField, keysSorted = false) => mapType(\n  keysSorted,\n  field(\n    'entries',\n    struct([ asField(keyField, 'key', false), asField(valueField, 'value') ]),\n    false\n  )\n);\n\n/**\n * Return a Duration data type instance. Durations represent an absolute length\n * of time unrelated to any calendar artifacts. The resolution defaults to\n * millisecond, but can be any of the other `TimeUnit` values. This type is\n * always represented as a 64-bit integer.\n * @param {TimeUnit_} unit\n * @returns {DurationType} The duration data type.\n */\nexport const duration = (unit = TimeUnit.MILLISECOND) => ({\n  typeId: Type.Duration,\n  unit: checkOneOf(unit, TimeUnit),\n  values: int64Array\n});\n\n/**\n * Return a LargeBinary data type instance for variably-sized opaque binary\n * data with 64-bit offsets, allowing representation of extremely large data\n * values.\n * @returns {LargeBinaryType} The large binary data type.\n */\nexport const largeBinary = () => ({\n  typeId: Type.LargeBinary,\n  offsets: int64Array\n});\n\n/**\n * Return a LargeUtf8 data type instance for Unicode string data of variable\n * length with 64-bit offsets, allowing representation of extremely large data\n * values. [UTF-8](https://en.wikipedia.org/wiki/UTF-8) code points are stored\n * as binary data.\n * @returns {LargeUtf8Type} The large utf8 data type.\n */\nexport const largeUtf8 = () => ({\n  typeId: Type.LargeUtf8,\n  offsets: int64Array\n});\n\n/**\n * Return a LargeList data type instance, representing variably-sized lists\n * (arrays) with 64-bit offsets, allowing representation of extremely large\n * data values. A list has a single child data type for list entries. Lists\n * are represented using integer offsets that indicate list extents within a\n * single child array containing all list values.\n * @param {FieldInput} child The child (list item) field or data type.\n * @returns {LargeListType} The large list data type.\n */\nexport const largeList = (child) => ({\n  typeId: Type.LargeList,\n  children: [ asField(child) ],\n  offsets: int64Array\n});\n\n/**\n * Return a RunEndEncoded data type instance, which compresses data by\n * representing consecutive repeated values as a run. This data type uses two\n * child arrays, `run_ends` and `values`. The `run_ends` child array must be\n * a 16, 32, or 64 bit integer array which encodes the indices at which the\n * run with the value in each corresponding index in the values child array\n * ends. Like list and struct types, the `values` array can be of any type.\n * @param {FieldInput} runsField The run-ends field or data type.\n * @param {FieldInput} valuesField The values field or data type.\n * @returns {RunEndEncodedType} The large list data type.\n */\nexport const runEndEncoded = (runsField, valuesField) => ({\n  typeId: Type.RunEndEncoded,\n  children: [\n    check(\n      asField(runsField, 'run_ends'),\n      (field) => field.type.typeId === Type.Int,\n      () => 'Run-ends must have an integer type.'\n    ),\n    asField(valuesField, 'values')\n  ]\n});\n\n/**\n * Return a BinaryView data type instance. BinaryView data is logically the\n * same as the Binary type, but the internal representation uses a view struct\n * that contains the string length and either the string's entire data inline\n * (for small strings) or an inlined prefix, an index of another buffer, and an\n * offset pointing to a slice in that buffer (for non-small strings).\n *\n * Flechette can encode and decode BinaryView data; however, Flechette does\n * not currently support building BinaryView columns from JavaScript values.\n * @returns {BinaryViewType} The binary view data type.\n */\nexport const binaryView = () => /** @type {BinaryViewType} */\n  (basicType(Type.BinaryView));\n\n/**\n * Return a Utf8View data type instance. Utf8View data is logically the same as\n * the Utf8 type, but the internal representation uses a view struct that\n * contains the string length and either the string's entire data inline (for\n * small strings) or an inlined prefix, an index of another buffer, and an\n * offset pointing to a slice in that buffer (for non-small strings).\n *\n * Flechette can encode and decode Utf8View data; however, Flechette does\n * not currently support building Utf8View columns from JavaScript values.\n * @returns {Utf8ViewType} The utf8 view data type.\n */\nexport const utf8View = () => /** @type {Utf8ViewType} */\n  (basicType(Type.Utf8View));\n\n/**\n * Return a ListView data type instance, representing variably-sized lists\n * (arrays) with 32-bit offsets. ListView data represents the same logical\n * types that List can, but contains both offsets and sizes allowing for\n * writes in any order and sharing of child values among list values.\n *\n * Flechette can encode and decode ListView data; however, Flechette does not\n * currently support building ListView columns from JavaScript values.\n * @param {FieldInput} child The child (list item) field or data type.\n * @returns {ListViewType} The list view data type.\n */\nexport const listView = (child) => ({\n  typeId: Type.ListView,\n  children: [ asField(child, 'value') ],\n  offsets: int32Array\n});\n\n/**\n * Return a LargeListView data type instance, representing variably-sized lists\n * (arrays) with 64-bit offsets, allowing representation of extremely large\n * data values. LargeListView data represents the same logical types that\n * LargeList can, but contains both offsets and sizes allowing for writes\n * in any order and sharing of child values among list values.\n *\n * Flechette can encode and decode LargeListView data; however, Flechette does\n * not currently support building LargeListView columns from JavaScript values.\n * @param {FieldInput} child The child (list item) field or data type.\n * @returns {LargeListViewType} The large list view data type.\n */\nexport const largeListView = (child) => ({\n  typeId: Type.LargeListView,\n  children: [ asField(child, 'value') ],\n  offsets: int64Array\n});\n","/**\n * @import { TimeUnit_, TypedArray } from '../types.js';\n */\nimport { float64Array, int32Array, int64Array, isInt64ArrayType, uint32Array, uint8Array } from './arrays.js';\nimport { TimeUnit } from '../constants.js';\n\n// typed arrays over a shared buffer to aid binary conversion\nconst f64 = new float64Array(2);\nconst buf = f64.buffer;\nconst i64 = new int64Array(buf);\nconst u32 = new uint32Array(buf);\nconst i32 = new int32Array(buf);\nconst u8 = new uint8Array(buf);\n\n/**\n * Return a value unchanged.\n * @template T\n * @param {T} value The value.\n * @returns {T} The value.\n */\nexport function identity(value) {\n  return value;\n}\n\n/**\n * Return a value coerced to a BigInt.\n * @param {*} value The value.\n * @returns {bigint} The BigInt value.\n */\nexport function toBigInt(value) {\n  return BigInt(value);\n}\n\n/**\n * Return an offset conversion method for the given data type.\n * @param {{ offsets: TypedArray}} type The array type.\n */\nexport function toOffset(type) {\n  return isInt64ArrayType(type) ? toBigInt : identity;\n}\n\n/**\n * Return the number of days from a millisecond timestamp.\n * @param {number} value The millisecond timestamp.\n * @returns {number} The number of days.\n */\nexport function toDateDay(value) {\n  return (value / 864e5) | 0;\n}\n\n/**\n * Return a timestamp conversion method for the given time unit.\n * @param {TimeUnit_} unit The time unit.\n * @returns {(value: number) => bigint} The conversion method.\n */\nexport function toTimestamp(unit) {\n  return unit === TimeUnit.SECOND ? value => toBigInt(value / 1e3)\n    : unit === TimeUnit.MILLISECOND ? toBigInt\n    : unit === TimeUnit.MICROSECOND ? value => toBigInt(value * 1e3)\n    : value => toBigInt(value * 1e6);\n}\n\n/**\n * Write month/day/nanosecond interval to a byte buffer.\n * @param {Array | Float64Array} interval The interval data.\n * @returns {Uint8Array} A byte buffer with the interval data.\n *  The returned buffer is reused across calls, and so should be\n *  copied to a target buffer immediately.\n */\nexport function toMonthDayNanoBytes([m, d, n]) {\n  i32[0] = m;\n  i32[1] = d;\n  i64[1] = toBigInt(n);\n  return u8;\n}\n\n/**\n * Coerce a bigint value to a number. Throws an error if the bigint value\n * lies outside the range of what a number can precisely represent.\n * @param {bigint} value The value to check and possibly convert.\n * @returns {number} The converted number value.\n */\nexport function toNumber(value) {\n  if (value > Number.MAX_SAFE_INTEGER || value < Number.MIN_SAFE_INTEGER) {\n    throw Error(`BigInt exceeds integer number representation: ${value}`);\n  }\n  return Number(value);\n}\n\n/**\n * Divide one BigInt value by another, and return the result as a number.\n * The division may involve unsafe integers and a loss of precision.\n * @param {bigint} num The numerator.\n * @param {bigint} div The divisor.\n * @returns {number} The result of the division as a floating point number.\n */\nexport function divide(num, div) {\n  return Number(num / div) + Number(num % div) / Number(div);\n}\n\n/**\n * Return a 32-bit decimal conversion method for the given decimal scale.\n * @param {number} scale The scale mapping fractional digits to integers.\n * @returns {(value: number|bigint) => number} A conversion method that maps\n *  floating point numbers to 32-bit decimals.\n */\nexport function toDecimal32(scale) {\n  return (value) => typeof value === 'bigint'\n    ? Number(value)\n    : Math.trunc(value * scale);\n}\n\n/**\n * Convert a floating point number or bigint to decimal bytes.\n * @param {number|bigint} value The number to encode. If a bigint, we assume\n *  it already represents the decimal in integer form with the correct scale.\n *  Otherwise, we assume a float that requires scaled integer conversion.\n * @param {BigUint64Array} buf The uint64 array to write to.\n * @param {number} offset The starting index offset into the array.\n * @param {number} stride The stride of an encoded decimal, in 64-bit steps.\n * @param {number} scale The scale mapping fractional digits to integers.\n */\nexport function toDecimal(value, buf, offset, stride, scale) {\n  const v = typeof value === 'bigint'\n    ? value\n    : toBigInt(Math.trunc(value * scale));\n  // assignment into uint64array performs needed truncation for us\n  buf[offset] = v;\n  if (stride > 1) {\n    buf[offset + 1] = (v >> 64n);\n    if (stride > 2) {\n      buf[offset + 2] = (v >> 128n);\n      buf[offset + 3] = (v >> 192n);\n    }\n  }\n}\n\n// helper method to extract uint64 values from bigints\nconst asUint64 = v => BigInt.asUintN(64, v);\n\n/**\n * Convert a 64-bit decimal value to a bigint.\n * @param {BigUint64Array} buf The uint64 array containing the decimal bytes.\n * @param {number} offset The starting index offset into the array.\n * @returns {bigint} The converted decimal as a bigint, such that all\n *  fractional digits are scaled up to integers (for example, 1.12 -> 112).\n */\nexport function fromDecimal64(buf, offset) {\n  return BigInt.asIntN(64, buf[offset]);\n}\n\n/**\n * Convert a 128-bit decimal value to a bigint.\n * @param {BigUint64Array} buf The uint64 array containing the decimal bytes.\n * @param {number} offset The starting index offset into the array.\n * @returns {bigint} The converted decimal as a bigint, such that all\n *  fractional digits are scaled up to integers (for example, 1.12 -> 112).\n */\nexport function fromDecimal128(buf, offset) {\n  const i = offset << 1;\n  let x;\n  if (BigInt.asIntN(64, buf[i + 1]) < 0) {\n    x = asUint64(~buf[i]) | (asUint64(~buf[i + 1]) << 64n);\n    x = -(x + 1n);\n  } else {\n    x = buf[i] | (buf[i + 1] << 64n);\n  }\n  return x;\n}\n\n/**\n * Convert a 256-bit decimal value to a bigint.\n * @param {BigUint64Array} buf The uint64 array containing the decimal bytes.\n * @param {number} offset The starting index offset into the array.\n * @returns {bigint} The converted decimal as a bigint, such that all\n *  fractional digits are scaled up to integers (for example, 1.12 -> 112).\n */\nexport function fromDecimal256(buf, offset) {\n  const i = offset << 2;\n  let x;\n  if (BigInt.asIntN(64, buf[i + 3]) < 0) {\n    x = asUint64(~buf[i])\n      | (asUint64(~buf[i + 1]) << 64n)\n      | (asUint64(~buf[i + 2]) << 128n)\n      | (asUint64(~buf[i + 3]) << 192n);\n    x = -(x + 1n);\n  } else {\n    x = buf[i]\n      | (buf[i + 1] << 64n)\n      | (buf[i + 2] << 128n)\n      | (buf[i + 3] << 192n);\n  }\n  return x;\n}\n\n/**\n * Convert a 16-bit float from integer bytes to a number.\n * Adapted from https://github.com/apache/arrow/blob/main/js/src/util/math.ts\n * @param {number} value The float as a 16-bit integer.\n * @returns {number} The converted 64-bit floating point number.\n */\nexport function fromFloat16(value) {\n  const expo = (value & 0x7C00) >> 10;\n  const sigf = (value & 0x03FF) / 1024;\n  const sign = (-1) ** ((value & 0x8000) >> 15);\n  switch (expo) {\n    case 0x1F: return sign * (sigf ? Number.NaN : 1 / 0);\n    case 0x00: return sign * (sigf ? 6.103515625e-5 * sigf : 0);\n  }\n  return sign * (2 ** (expo - 15)) * (1 + sigf);\n}\n\n/**\n * Convert a number to a 16-bit float as integer bytes..\n * Inspired by numpy's `npy_double_to_half`:\n * https://github.com/numpy/numpy/blob/5a5987291dc95376bb098be8d8e5391e89e77a2c/numpy/core/src/npymath/halffloat.c#L43\n * Adapted from https://github.com/apache/arrow/blob/main/js/src/util/math.ts\n * @param {number} value The 64-bit floating point number to convert.\n * @returns {number} The converted 16-bit integer.\n */\nexport function toFloat16(value) {\n  if (value !== value) return 0x7E00; // NaN\n  f64[0] = value;\n\n  // Magic numbers:\n  // 0x80000000 = 10000000 00000000 00000000 00000000 -- masks the 32nd bit\n  // 0x7ff00000 = 01111111 11110000 00000000 00000000 -- masks the 21st-31st bits\n  // 0x000fffff = 00000000 00001111 11111111 11111111 -- masks the 1st-20th bit\n  const sign = (u32[1] & 0x80000000) >> 16 & 0xFFFF;\n  let expo = (u32[1] & 0x7FF00000), sigf = 0x0000;\n\n  if (expo >= 0x40F00000) {\n    //\n    // If exponent overflowed, the float16 is either NaN or Infinity.\n    // Rules to propagate the sign bit: mantissa > 0 ? NaN : +/-Infinity\n    //\n    // Magic numbers:\n    // 0x40F00000 = 01000000 11110000 00000000 00000000 -- 6-bit exponent overflow\n    // 0x7C000000 = 01111100 00000000 00000000 00000000 -- masks the 27th-31st bits\n    //\n    // returns:\n    // qNaN, aka 32256 decimal, 0x7E00 hex, or 01111110 00000000 binary\n    // sNaN, aka 32000 decimal, 0x7D00 hex, or 01111101 00000000 binary\n    // +inf, aka 31744 decimal, 0x7C00 hex, or 01111100 00000000 binary\n    // -inf, aka 64512 decimal, 0xFC00 hex, or 11111100 00000000 binary\n    //\n    // If mantissa is greater than 23 bits, set to +Infinity like numpy\n    if (u32[0] > 0) {\n      expo = 0x7C00;\n    } else {\n      expo = (expo & 0x7C000000) >> 16;\n      sigf = (u32[1] & 0x000FFFFF) >> 10;\n    }\n  } else if (expo <= 0x3F000000) {\n    //\n    // If exponent underflowed, the float is either signed zero or subnormal.\n    //\n    // Magic numbers:\n    // 0x3F000000 = 00111111 00000000 00000000 00000000 -- 6-bit exponent underflow\n    //\n    sigf = 0x100000 + (u32[1] & 0x000FFFFF);\n    sigf = 0x100000 + (sigf << ((expo >> 20) - 998)) >> 21;\n    expo = 0;\n  } else {\n    //\n    // No overflow or underflow, rebase the exponent and round the mantissa\n    // Magic numbers:\n    // 0x200 = 00000010 00000000 -- masks off the 10th bit\n    //\n    // Ensure the first mantissa bit (the 10th one) is 1 and round\n    expo = (expo - 0x3F000000) >> 10;\n    sigf = ((u32[1] & 0x000FFFFF) + 0x200) >> 10;\n  }\n  return sign | expo | sigf & 0xFFFF;\n}\n","import { isArray } from './arrays.js';\nimport { isDate } from './objects.js';\n\nconst textDecoder = new TextDecoder('utf-8');\nconst textEncoder = new TextEncoder();\n\n/**\n * Return a UTF-8 string decoded from a byte buffer.\n * @param {Uint8Array} buf The byte buffer.\n * @returns {string} The decoded string.\n */\nexport function decodeUtf8(buf) {\n  return textDecoder.decode(buf);\n}\n\n/**\n * Return a byte buffer encoded from a UTF-8 string.\n * @param {string } str The string to encode.\n * @returns {Uint8Array} The encoded byte buffer.\n */\nexport function encodeUtf8(str) {\n  return textEncoder.encode(str);\n}\n\n/**\n * Return a string-coercible key value that uniquely identifies a value.\n * @param {*} value The input value.\n * @returns {string} The key string.\n */\nexport function keyString(value) {\n  const val = typeof value !== 'object' || !value ? (value ?? null)\n    : isDate(value) ? +value\n    // @ts-ignore\n    : isArray(value) ? `[${value.map(keyString)}]`\n    : objectKey(value);\n  return `${val}`;\n}\n\nfunction objectKey(value) {\n  let s = '';\n  let i = -1;\n  for (const k in value) {\n    if (++i > 0) s += ',';\n    s += `\"${k}\":${keyString(value[k])}`;\n  }\n  return `{${s}}`;\n}\n","import { toNumber } from './numbers.js';\nimport { decodeUtf8 } from './strings.js';\n\n/** The size in bytes of a 32-bit integer. */\nexport const SIZEOF_INT = 4;\n\n/** The size in bytes of a 16-bit integer. */\nexport const SIZEOF_SHORT = 2;\n\n/**\n * Return a boolean for a single bit in a bitmap.\n * @param {Uint8Array} bitmap The bitmap.\n * @param {number} index The bit index to read.\n * @returns {boolean} The boolean bitmap value.\n */\nexport function decodeBit(bitmap, index) {\n  return (bitmap[index >> 3] & 1 << (index % 8)) !== 0;\n}\n\n/**\n * Lookup helper for flatbuffer object (table) entries.\n * @param {Uint8Array} buf The byte buffer.\n * @param {number} index The base index of the object.\n */\nexport function readObject(buf, index) {\n  const pos = index + readInt32(buf, index);\n  const vtable = pos - readInt32(buf, pos);\n  const size = readInt16(buf, vtable);\n  /**\n   * Retrieve a value from a flatbuffer table layout.\n   * @template T\n   * @param {number} index The table entry index.\n   * @param {(buf: Uint8Array, offset: number) => T} read Read function to invoke.\n   * @param {T} [fallback=null] The default fallback value.\n   * @returns {T}\n   */\n  return (index, read, fallback = null) => {\n    if (index < size) {\n      const off = readInt16(buf, vtable + index);\n      if (off) return read(buf, pos + off);\n    }\n    return fallback;\n  };\n}\n\n/**\n * Return a buffer offset value.\n * @param {Uint8Array} buf\n * @param {number} offset\n * @returns {number}\n */\nexport function readOffset(buf, offset) {\n  return offset;\n}\n\n/**\n * Return a boolean value.\n * @param {Uint8Array} buf\n * @param {number} offset\n * @returns {boolean}\n */\nexport function readBoolean(buf, offset) {\n  return !!readInt8(buf, offset);\n}\n\n/**\n * Return a signed 8-bit integer value.\n * @param {Uint8Array} buf\n * @param {number} offset\n * @returns {number}\n */\nexport function readInt8(buf, offset) {\n  return readUint8(buf, offset) << 24 >> 24;\n}\n\n/**\n * Return an unsigned 8-bit integer value.\n * @param {Uint8Array} buf\n * @param {number} offset\n * @returns {number}\n */\nexport function readUint8(buf, offset) {\n  return buf[offset];\n}\n\n/**\n * Return a signed 16-bit integer value.\n * @param {Uint8Array} buf\n * @param {number} offset\n * @returns {number}\n */\nexport function readInt16(buf, offset) {\n  return readUint16(buf, offset) << 16 >> 16;\n}\n\n/**\n * Return an unsigned 16-bit integer value.\n * @param {Uint8Array} buf\n * @param {number} offset\n * @returns {number}\n */\nexport function readUint16(buf, offset) {\n  return buf[offset] | buf[offset + 1] << 8;\n}\n\n/**\n * Return a signed 32-bit integer value.\n * @param {Uint8Array} buf\n * @param {number} offset\n * @returns {number}\n */\nexport function readInt32(buf, offset) {\n  return buf[offset]\n    | buf[offset + 1] << 8\n    | buf[offset + 2] << 16\n    | buf[offset + 3] << 24;\n}\n\n/**\n * Return an unsigned 32-bit integer value.\n * @param {Uint8Array} buf\n * @param {number} offset\n * @returns {number}\n */\nexport function readUint32(buf, offset) {\n  return readInt32(buf, offset) >>> 0;\n}\n\n/**\n * Return a signed 64-bit integer value coerced to a JS number.\n * Throws an error if the value exceeds what a JS number can represent.\n * @param {Uint8Array} buf\n * @param {number} offset\n * @returns {number}\n */\nexport function readInt64(buf, offset) {\n  return toNumber(BigInt.asIntN(\n    64,\n    BigInt(readUint32(buf, offset)) +\n      (BigInt(readUint32(buf, offset + SIZEOF_INT)) << 32n)\n  ));\n}\n\n/**\n * Create a JavaScript string from UTF-8 data stored inside the FlatBuffer.\n * This allocates a new string and converts to wide chars upon each access.\n * @param {Uint8Array} buf The byte buffer.\n * @param {number} index The index of the string entry.\n * @returns {string} The decoded string.\n */\nexport function readString(buf, index) {\n  let offset = index + readInt32(buf, index); // get the string offset\n  const length = readInt32(buf, offset);  // get the string length\n  offset += SIZEOF_INT; // skip length value\n  return decodeUtf8(buf.subarray(offset, offset + length));\n}\n\n/**\n * Extract a flatbuffer vector to an array.\n * @template T\n * @param {Uint8Array} buf The byte buffer.\n * @param {number} offset The offset location of the vector.\n * @param {number} stride The stride between vector entries.\n * @param {(buf: Uint8Array, pos: number) => T} extract Vector entry extraction function.\n * @returns {T[]} The extracted vector entries.\n */\nexport function readVector(buf, offset, stride, extract) {\n  if (!offset) return [];\n\n  // get base position by adding offset delta\n  const base = offset + readInt32(buf, offset);\n\n  // read vector size, extract entries\n  return Array.from(\n    { length: readInt32(buf, base) },\n    (_, i) => extract(buf, base + SIZEOF_INT + i * stride)\n  );\n}\n","/**\n * @import { Batch } from '../batch.js';\n */\n\n/**\n * Symbol for the row index value of a struct object proxy.\n */\nexport const RowIndex = Symbol('rowIndex');\n\n/**\n * Returns a row proxy object factory. The resulting method takes a\n * batch-level row index as input and returns an object that proxies\n * access to underlying batches.\n * @param {string[]} names The column (property) names\n * @param {Batch[]} batches The value batches.\n * @returns {(index: number) => Record<string, any>}\n */\nexport function proxyFactory(names, batches) {\n  class RowObject {\n    /**\n     * Create a new proxy row object representing a struct or table row.\n     * @param {number} index The record batch row index.\n     */\n    constructor(index) {\n      this[RowIndex] = index;\n    }\n\n    /**\n     * Return a JSON-compatible object representation.\n     */\n    toJSON() {\n      return structObject(names, batches, this[RowIndex]);\n    }\n  };\n\n  // prototype for row proxy objects\n  const proto = RowObject.prototype;\n\n  for (let i = 0; i < names.length; ++i) {\n    // skip duplicated column names\n    if (Object.hasOwn(proto, names[i])) continue;\n\n    // add a getter method for the current batch\n    const batch = batches[i];\n    Object.defineProperty(proto, names[i], {\n      get() { return batch.at(this[RowIndex]); },\n      enumerable: true\n    });\n  }\n\n  return index => new RowObject(index);\n}\n\n/**\n * Returns a row object factory. The resulting method takes a\n * batch-level row index as input and returns an object whose property\n * values have been extracted from the batches.\n * @param {string[]} names The column (property) names\n * @param {Batch[]} batches The value batches.\n * @returns {(index: number) => Record<string, any>}\n */\nexport function objectFactory(names, batches) {\n  return index => structObject(names, batches, index);\n}\n\n/**\n * Return a vanilla object representing a struct (row object) type.\n * @param {string[]} names The column (property) names\n * @param {Batch[]} batches The value batches.\n * @param {number} index The record batch row index.\n * @returns {Record<string, any>}\n */\nexport function structObject(names, batches, index) {\n  const obj = {};\n  for (let i = 0; i < names.length; ++i) {\n    obj[names[i]] = batches[i].at(index);\n  }\n  return obj;\n}\n","/**\n * @import { Column } from './column.js'\n * @import { DataType, DecimalType, IntegerArray, OffsetArray, TypedArray, TypedArrayConstructor, ValueArray } from './types.js'\n */\nimport { bisect, float64Array } from './util/arrays.js';\nimport { divide, fromDecimal128, fromDecimal256, fromDecimal64, toNumber } from './util/numbers.js';\nimport { decodeBit, readInt32, readInt64 } from './util/read.js';\nimport { decodeUtf8 } from './util/strings.js';\nimport { objectFactory, proxyFactory } from './util/struct.js';\n\n/**\n * Check if the input is a batch that supports direct access to\n * binary data in the form of typed arrays.\n * @param {Batch<any>?} batch The data batch to check.\n * @returns {boolean} True if a direct batch, false otherwise.\n */\nexport function isDirectBatch(batch) {\n  return batch instanceof DirectBatch;\n}\n\n/**\n * Column values from a single record batch.\n * A column may contain multiple batches.\n * @template T\n */\nexport class Batch {\n  /**\n   * The array type to use when extracting data from the batch.\n   * A null value indicates that the array type should match\n   * the type of the batch's values array.\n   * @type {ArrayConstructor | TypedArrayConstructor | null}\n   */\n  static ArrayType = null;\n\n  /**\n   * Create a new column batch.\n   * @param {object} options\n   * @param {number} options.length The length of the batch\n   * @param {number} options.nullCount The null value count\n   * @param {DataType} options.type The data type.\n   * @param {Uint8Array} [options.validity] Validity bitmap buffer\n   * @param {TypedArray} [options.values] Values buffer\n   * @param {OffsetArray} [options.offsets] Offsets buffer\n   * @param {OffsetArray} [options.sizes] Sizes buffer\n   * @param {Batch[]} [options.children] Children batches\n   */\n  constructor({\n    length,\n    nullCount,\n    type,\n    validity,\n    values,\n    offsets,\n    sizes,\n    children\n  }) {\n    this.length = length;\n    this.nullCount = nullCount;\n    this.type = type;\n    this.validity = validity;\n    this.values = values;\n    this.offsets = offsets;\n    this.sizes = sizes;\n    this.children = children;\n\n    // optimize access if this batch has no null values\n    // some types (like union) may have null values in\n    // child batches, but no top-level validity buffer\n    if (!nullCount || !this.validity) {\n      /** @type {(index: number) => T | null} */\n      this.at = index => this.value(index);\n    }\n  }\n\n  /**\n   * Provide an informative object string tag.\n   */\n  get [Symbol.toStringTag]() {\n    return 'Batch';\n  }\n\n  /**\n   * Return the value at the given index.\n   * @param {number} index The value index.\n   * @returns {T | null} The value.\n   */\n  at(index) {\n    return this.isValid(index) ? this.value(index) : null;\n  }\n\n  /**\n   * Check if a value at the given index is valid (non-null).\n   * @param {number} index The value index.\n   * @returns {boolean} True if valid, false otherwise.\n   */\n  isValid(index) {\n    return decodeBit(this.validity, index);\n  }\n\n  /**\n   * Return the value at the given index. This method does not check the\n   * validity bitmap and is intended primarily for internal use. In most\n   * cases, callers should use the `at()` method instead.\n   * @param {number} index The value index\n   * @returns {T} The value, ignoring the validity bitmap.\n   */\n  value(index) {\n    return /** @type {T} */ (this.values[index]);\n  }\n\n  /**\n   * Extract an array of values within the given index range. Unlike\n   * Array.slice, all arguments are required and may not be negative indices.\n   * @param {number} start The starting index, inclusive\n   * @param {number} end The ending index, exclusive\n   * @returns {ValueArray<T?>} The slice of values\n   */\n  slice(start, end) {\n    const n = end - start;\n    const values = Array(n);\n    for (let i = 0; i < n; ++i) {\n      values[i] = this.at(start + i);\n    }\n    return values;\n  }\n\n  /**\n   * Return an iterator over the values in this batch.\n   * @returns {Iterator<T?>}\n   */\n  *[Symbol.iterator]() {\n    for (let i = 0; i < this.length; ++i) {\n      yield this.at(i);\n    }\n  }\n}\n\n/**\n * A batch whose value buffer can be used directly, without transformation.\n * @template T\n * @extends {Batch<T>}\n */\nexport class DirectBatch extends Batch {\n  /**\n   * Create a new column batch with direct value array access.\n   * @param {object} options\n   * @param {number} options.length The length of the batch\n   * @param {number} options.nullCount The null value count\n   * @param {DataType} options.type The data type.\n   * @param {Uint8Array} [options.validity] Validity bitmap buffer\n   * @param {TypedArray} options.values Values buffer\n   */\n  constructor(options) {\n    super(options);\n    // underlying buffers may be padded, exceeding the logical batch length\n    // we trim the values array so we can safely access it directly\n    const { length, values } = this;\n    this.values = values.subarray(0, length);\n  }\n\n  /**\n   * Extract an array of values within the given index range. Unlike\n   * Array.slice, all arguments are required and may not be negative indices.\n   * When feasible, a zero-copy subarray of a typed array is returned.\n   * @param {number} start The starting index, inclusive\n   * @param {number} end The ending index, exclusive\n   * @returns {ValueArray<T?>} The slice of values\n   */\n  slice(start, end) {\n    // @ts-ignore\n    return this.nullCount\n      ? super.slice(start, end)\n      : this.values.subarray(start, end);\n  }\n\n  /**\n   * Return an iterator over the values in this batch.\n   * @returns {Iterator<T?>}\n   */\n  [Symbol.iterator]() {\n    return this.nullCount\n      ? super[Symbol.iterator]()\n      : /** @type {Iterator<T?>} */ (this.values[Symbol.iterator]());\n  }\n}\n\n/**\n * A batch whose values are transformed to 64-bit numbers.\n * @extends {Batch<number>}\n */\nexport class NumberBatch extends Batch {\n  static ArrayType = float64Array;\n}\n\n/**\n * A batch whose values should be returned in a standard array.\n * @template T\n * @extends {Batch<T>}\n */\nexport class ArrayBatch extends Batch {\n  static ArrayType = Array;\n}\n\n/**\n * A batch of null values only.\n * @extends {ArrayBatch<null>}\n */\nexport class NullBatch extends ArrayBatch {\n  /**\n   * @param {number} index The value index\n   * @returns {null}\n   */\n  value(index) { // eslint-disable-line no-unused-vars\n    return null;\n  }\n}\n\n/**\n * A batch that coerces BigInt values to 64-bit numbers.\n * @extends {NumberBatch}\n */\nexport class Int64Batch extends NumberBatch {\n  /**\n   * @param {number} index The value index\n   */\n  value(index) {\n    return toNumber(/** @type {bigint} */ (this.values[index]));\n  }\n}\n\n/**\n * A batch of 16-bit floating point numbers, accessed as unsigned\n * 16-bit ints and transformed to 64-bit numbers.\n */\nexport class Float16Batch extends NumberBatch {\n  /**\n   * @param {number} index The value index\n   */\n  value(index) {\n    const v = /** @type {number} */ (this.values[index]);\n    const expo = (v & 0x7C00) >> 10;\n    const sigf = (v & 0x03FF) / 1024;\n    const sign = (-1) ** ((v & 0x8000) >> 15);\n    switch (expo) {\n      case 0x1F: return sign * (sigf ? Number.NaN : 1 / 0);\n      case 0x00: return sign * (sigf ? 6.103515625e-5 * sigf : 0);\n    }\n    return sign * (2 ** (expo - 15)) * (1 + sigf);\n  }\n}\n\n/**\n * A batch of boolean values stored as a bitmap.\n * @extends {ArrayBatch<boolean>}\n */\nexport class BoolBatch extends ArrayBatch {\n  /**\n   * @param {number} index The value index\n   */\n  value(index) {\n    return decodeBit(/** @type {Uint8Array} */ (this.values), index);\n  }\n}\n\n/**\n * A batch of 32-bit decimal numbers, returned as converted 64-bit floating\n * point numbers. Number coercion may be lossy if the decimal precision can\n * not be represented in a 64-bit floating point format.\n * @extends {NumberBatch}\n */\nexport class Decimal32NumberBatch extends NumberBatch {\n  constructor(options) {\n    super(options);\n    const { scale } = /** @type {DecimalType} */ (this.type);\n    this.scale = 10 ** scale;\n  }\n  /**\n   * @param {number} index The value index\n   */\n  value(index) {\n    return /** @type {number} */(this.values[index]) / this.scale;\n  }\n}\n\n/**\n * An abstract class for a batch of 64-, 128- or 256-bit decimal numbers,\n * accessed in strided BigUint64Arrays.\n * @template T\n * @extends {Batch<T>}\n */\nexport class DecimalBatch extends Batch {\n  constructor(options) {\n    super(options);\n    const { bitWidth, scale } = /** @type {DecimalType} */ (this.type);\n    this.decimal = bitWidth === 64 ? fromDecimal64\n      : bitWidth === 128 ? fromDecimal128\n      : fromDecimal256;\n    this.scale = 10n ** BigInt(scale);\n  }\n}\n\n/**\n * A batch of 64-, 128- or 256-bit decimal numbers, returned as converted\n * 64-bit floating point numbers. Number coercion may be lossy if the decimal\n * precision can not be represented in a 64-bit floating point format.\n * @extends {DecimalBatch<number>}\n */\nexport class DecimalNumberBatch extends DecimalBatch {\n  static ArrayType = float64Array;\n  /**\n   * @param {number} index The value index\n   */\n  value(index) {\n    return divide(\n      this.decimal(/** @type {BigUint64Array} */ (this.values), index),\n      this.scale\n    );\n  }\n}\n\n/**\n * A batch of 64-, 128- or 256-bit decimal numbers, returned as scaled\n * bigint values, such that all fractional digits have been shifted\n * to integer places by the decimal type scale factor.\n * @extends {DecimalBatch<bigint>}\n */\nexport class DecimalBigIntBatch extends DecimalBatch {\n  static ArrayType = Array;\n  /**\n   * @param {number} index The value index\n   */\n  value(index) {\n    return this.decimal(/** @type {BigUint64Array} */ (this.values), index);\n  }\n}\n\n/**\n * A batch of date or timestamp values that are coerced to UNIX epoch timestamps\n * and returned as JS Date objects. This batch wraps a source batch that provides\n * timestamp values.\n * @extends {ArrayBatch<Date>}\n */\nexport class DateBatch extends ArrayBatch {\n  /**\n   * Create a new date batch.\n   * @param {Batch<number>} batch A batch of timestamp values.\n   */\n  constructor(batch) {\n    super(batch);\n    this.source = batch;\n  }\n\n  /**\n   * @param {number} index The value index\n   */\n  value(index) {\n    return new Date(this.source.value(index));\n  }\n}\n\n/**\n * A batch of dates as day counts, coerced to timestamp numbers.\n */\nexport class DateDayBatch extends NumberBatch {\n  /**\n   * @param {number} index The value index\n   * @returns {number}\n   */\n  value(index) {\n    // epoch days to milliseconds\n    return 86400000 * /** @type {number} */ (this.values[index]);\n  }\n}\n\n/**\n * A batch of dates as millisecond timestamps, coerced to numbers.\n */\nexport const DateDayMillisecondBatch = Int64Batch;\n\n/**\n * A batch of timestaps in seconds, coerced to millisecond numbers.\n */\nexport class TimestampSecondBatch extends Int64Batch {\n  /**\n   * @param {number} index The value index\n   */\n  value(index) {\n    return super.value(index) * 1e3; // seconds to milliseconds\n  }\n}\n\n/**\n * A batch of timestaps in milliseconds, coerced to numbers.\n */\nexport const TimestampMillisecondBatch = Int64Batch;\n\n/**\n * A batch of timestaps in microseconds, coerced to millisecond numbers.\n */\nexport class TimestampMicrosecondBatch extends Int64Batch {\n  /**\n   * @param {number} index The value index\n   */\n  value(index) {\n    // microseconds to milliseconds\n    return divide(/** @type {bigint} */ (this.values[index]), 1000n);\n  }\n}\n\n/**\n * A batch of timestaps in nanoseconds, coerced to millisecond numbers.\n */\nexport class TimestampNanosecondBatch extends Int64Batch {\n  /**\n   * @param {number} index The value index\n   */\n  value(index) {\n    // nanoseconds to milliseconds\n    return divide(/** @type {bigint} */ (this.values[index]), 1000000n);\n  }\n}\n\n/**\n * A batch of day/time intervals, returned as two-element 32-bit int arrays.\n * @extends {ArrayBatch<Int32Array>}\n */\nexport class IntervalDayTimeBatch extends ArrayBatch {\n  /**\n   * @param {number} index The value index\n   * @returns {Int32Array}\n   */\n  value(index) {\n    const values = /** @type {Int32Array} */ (this.values);\n    return values.subarray(index << 1, (index + 1) << 1);\n  }\n}\n\n/**\n * A batch of month/day/nanosecond intervals, returned as three-element arrays.\n * @extends {ArrayBatch<Float64Array>}\n */\nexport class IntervalMonthDayNanoBatch extends ArrayBatch {\n  /**\n   * @param {number} index The value index\n   */\n  value(index) {\n    const values = /** @type {Uint8Array} */ (this.values);\n    const base = index << 4;\n    return Float64Array.of(\n      readInt32(values, base),\n      readInt32(values, base + 4),\n      readInt64(values, base + 8)\n    );\n  }\n}\n\nconst offset32 = ({values, offsets}, index) => values.subarray(offsets[index], offsets[index + 1]);\nconst offset64 = ({values, offsets}, index) => values.subarray(toNumber(offsets[index]), toNumber(offsets[index + 1]));\n\n/**\n * A batch of binary blobs with variable offsets, returned as byte buffers of\n * unsigned 8-bit integers. The offsets are 32-bit ints.\n * @extends {ArrayBatch<Uint8Array>}\n */\nexport class BinaryBatch extends ArrayBatch {\n  /**\n   * @param {number} index\n   * @returns {Uint8Array}\n   */\n  value(index) {\n    return offset32(this, index);\n  }\n}\n\n/**\n * A batch of binary blobs with variable offsets, returned as byte buffers of\n * unsigned 8-bit integers. The offsets are 64-bit ints. Value extraction will\n * fail if an offset exceeds `Number.MAX_SAFE_INTEGER`.\n * @extends {ArrayBatch<Uint8Array>}\n */\nexport class LargeBinaryBatch extends ArrayBatch {\n  /**\n   * @param {number} index\n   * @returns {Uint8Array}\n   */\n  value(index) {\n    return offset64(this, index);\n  }\n}\n\n/**\n * A batch of UTF-8 strings with variable offsets. The offsets are 32-bit ints.\n * @extends {ArrayBatch<string>}\n */\nexport class Utf8Batch extends ArrayBatch {\n  /**\n   * @param {number} index\n   */\n  value(index) {\n    return decodeUtf8(offset32(this, index));\n  }\n}\n\n/**\n * A batch of UTF-8 strings with variable offsets. The offsets are 64-bit ints.\n * Value extraction will fail if an offset exceeds `Number.MAX_SAFE_INTEGER`.\n * @extends {ArrayBatch<string>}\n */\nexport class LargeUtf8Batch extends ArrayBatch {\n  /**\n   * @param {number} index\n   */\n  value(index) {\n    return decodeUtf8(offset64(this, index));\n  }\n}\n\n/**\n * A batch of list (array) values of variable length. The list offsets are\n * 32-bit ints.\n * @template V\n * @extends {ArrayBatch<ValueArray<V>>}\n */\nexport class ListBatch extends ArrayBatch {\n  /**\n   * @param {number} index\n   * @returns {ValueArray<V>}\n   */\n  value(index) {\n    const offsets = /** @type {Int32Array} */ (this.offsets);\n    return this.children[0].slice(offsets[index], offsets[index + 1]);\n  }\n}\n\n/**\n * A batch of list (array) values of variable length. The list offsets are\n * 64-bit ints. Value extraction will fail if an offset exceeds\n * `Number.MAX_SAFE_INTEGER`.\n * @template V\n * @extends {ArrayBatch<ValueArray<V>>}\n */\nexport class LargeListBatch extends ArrayBatch {\n  /**\n   * @param {number} index\n   * @returns {ValueArray<V>}\n   */\n  value(index) {\n    const offsets = /** @type {BigInt64Array} */ (this.offsets);\n    return this.children[0].slice(toNumber(offsets[index]), toNumber(offsets[index + 1]));\n  }\n}\n\n/**\n * A batch of list (array) values of variable length. The list offsets and\n * sizes are 32-bit ints.\n * @template V\n * @extends {ArrayBatch<ValueArray<V>>}\n */\nexport class ListViewBatch extends ArrayBatch {\n  /**\n   * @param {number} index\n   * @returns {ValueArray<V>}\n   */\n  value(index) {\n    const a = /** @type {number} */ (this.offsets[index]);\n    const b = a + /** @type {number} */ (this.sizes[index]);\n    return this.children[0].slice(a, b);\n  }\n}\n\n/**\n * A batch of list (array) values of variable length. The list offsets and\n * sizes are 64-bit ints. Value extraction will fail if an offset or size\n * exceeds `Number.MAX_SAFE_INTEGER`.\n * @template V\n * @extends {ArrayBatch<ValueArray<V>>}\n */\nexport class LargeListViewBatch extends ArrayBatch {\n  /**\n   * @param {number} index\n   * @returns {ValueArray<V>}\n   */\n  value(index) {\n    const a = /** @type {bigint} */ (this.offsets[index]);\n    const b = a + /** @type {bigint} */ (this.sizes[index]);\n    return this.children[0].slice(toNumber(a), toNumber(b));\n  }\n}\n\n/**\n * A batch with a fixed stride.\n * @template T\n * @extends {ArrayBatch<T>}\n */\nclass FixedBatch extends ArrayBatch {\n  constructor(options) {\n    super(options);\n    /** @type {number} */\n    // @ts-ignore\n    this.stride = this.type.stride;\n  }\n}\n\n/**\n * A batch of binary blobs of fixed size, returned as byte buffers of unsigned\n * 8-bit integers.\n * @extends {FixedBatch<Uint8Array>}\n */\nexport class FixedBinaryBatch extends FixedBatch {\n  /**\n   * @param {number} index\n   * @returns {Uint8Array}\n   */\n  value(index) {\n    const { stride, values } = this;\n    return /** @type {Uint8Array} */ (values)\n      .subarray(index * stride, (index + 1) * stride);\n  }\n}\n\n/**\n * A batch of list (array) values of fixed length.\n * @template V\n * @extends {FixedBatch<ValueArray<V>>}\n */\nexport class FixedListBatch extends FixedBatch {\n  /**\n   * @param {number} index\n   * @returns {ValueArray<V>}\n   */\n  value(index) {\n    const { children, stride } = this;\n    return children[0].slice(index * stride, (index + 1) * stride);\n  }\n}\n\n/**\n * Extract Map key-value pairs from parallel child batches.\n */\nfunction pairs({ children, offsets }, index) {\n  const [ keys, vals ] = children[0].children;\n  const start = offsets[index];\n  const end = offsets[index + 1];\n  const entries = [];\n  for (let i = start; i < end; ++i) {\n    entries.push([keys.at(i), vals.at(i)]);\n  }\n  return entries;\n}\n\n/**\n * A batch of map (key, value) values. The map is represented as a list of\n * key-value structs.\n * @template K, V\n * @extends {ArrayBatch<[K, V][]>}\n */\nexport class MapEntryBatch extends ArrayBatch {\n  /**\n   * Return the value at the given index.\n   * @param {number} index The value index.\n   * @returns {[K, V][]} The map entries as an array of [key, value] arrays.\n   */\n  value(index) {\n    return /** @type {[K, V][]} */ (pairs(this, index));\n  }\n}\n\n/**\n * A batch of map (key, value) values. The map is represented as a list of\n * key-value structs.\n * @template K, V\n * @extends {ArrayBatch<Map<K, V>>}\n */\nexport class MapBatch extends ArrayBatch {\n  /**\n   * Return the value at the given index.\n   * @param {number} index The value index.\n   * @returns {Map<K, V>} The map value.\n   */\n  value(index) {\n    return new Map(/** @type {[K, V][]} */ (pairs(this, index)));\n  }\n}\n\n/**\n * A batch of union-type values with a sparse layout, enabling direct\n * lookup from the child value batches.\n * @template T\n * @extends {ArrayBatch<T>}\n */\nexport class SparseUnionBatch extends ArrayBatch {\n  /**\n   * Create a new column batch.\n   * @param {object} options\n   * @param {number} options.length The length of the batch\n   * @param {number} options.nullCount The null value count\n   * @param {DataType} options.type The data type.\n   * @param {Uint8Array} [options.validity] Validity bitmap buffer\n   * @param {Int32Array} [options.offsets] Offsets buffer\n   * @param {Batch[]} options.children Children batches\n   * @param {Int8Array} options.typeIds Union type ids buffer\n   * @param {Record<string, number>} options.map A typeId to children index map\n   */\n  constructor({ typeIds, ...options }) {\n    super(options);\n    /** @type {Int8Array} */\n    this.typeIds = typeIds;\n    /** @type {Record<string, number>} */\n    // @ts-ignore\n    this.typeMap = this.type.typeMap;\n  }\n\n  /**\n   * @param {number} index The value index.\n   */\n  value(index, offset = index) {\n    const { typeIds, children, typeMap } = this;\n    return children[typeMap[typeIds[index]]].at(offset);\n  }\n}\n\n/**\n * A batch of union-type values with a dense layout, reqiring offset\n * lookups from the child value batches.\n * @template T\n * @extends {SparseUnionBatch<T>}\n */\nexport class DenseUnionBatch extends SparseUnionBatch {\n  /**\n   * @param {number} index The value index.\n   */\n  value(index) {\n    return super.value(index, /** @type {number} */ (this.offsets[index]));\n  }\n}\n\n/**\n * A batch of struct values, containing a set of named properties.\n * Struct property values are extracted and returned as JS objects.\n * @extends {ArrayBatch<Record<string, any>>}\n */\nexport class StructBatch extends ArrayBatch {\n  constructor(options, factory = objectFactory) {\n    super(options);\n    /** @type {string[]} */\n    // @ts-ignore\n    this.names = this.type.children.map(child => child.name);\n    this.factory = factory(this.names, this.children);\n  }\n\n  /**\n   * @param {number} index The value index.\n   * @returns {Record<string, any>}\n   */\n  value(index) {\n    return this.factory(index);\n  }\n}\n\n/**\n * A batch of struct values, containing a set of named properties.\n * Structs are returned as proxy objects that extract data directly\n * from underlying Arrow batches.\n * @extends {StructBatch}\n */\nexport class StructProxyBatch extends StructBatch {\n  constructor(options) {\n    super(options, proxyFactory);\n  }\n}\n\n/**\n * A batch of run-end-encoded values.\n * @template T\n * @extends {ArrayBatch<T>}\n */\nexport class RunEndEncodedBatch extends ArrayBatch {\n  /**\n   * @param {number} index The value index.\n   */\n  value(index) {\n    const [ { values: runs }, vals ] = this.children;\n    return vals.at(\n      bisect(/** @type {IntegerArray} */(runs), index)\n    );\n  }\n}\n\n/**\n * A batch of dictionary-encoded values.\n * @template T\n * @extends {ArrayBatch<T>}\n */\nexport class DictionaryBatch extends ArrayBatch {\n  /**\n   * Register the backing dictionary. Dictionaries are added\n   * after batch creation as the complete dictionary may not\n   * be finished across multiple record batches.\n   * @param {Column<T>} dictionary\n   * The dictionary of column values.\n   */\n  setDictionary(dictionary) {\n    this.dictionary = dictionary;\n    this.cache = dictionary.cache();\n    return this;\n  }\n\n  /**\n   * @param {number} index The value index.\n   */\n  value(index) {\n    return this.cache[this.key(index)];\n  }\n\n  /**\n   * @param {number} index The value index.\n   * @returns {number} The dictionary key\n   */\n  key(index) {\n    return /** @type {number} */ (this.values[index]);\n  }\n}\n\n/**\n * @template T\n * @extends {ArrayBatch<T>}\n */\nclass ViewBatch extends ArrayBatch {\n  /**\n   * Create a new view batch.\n   * @param {object} options Batch options.\n   * @param {number} options.length The length of the batch\n   * @param {number} options.nullCount The null value count\n   * @param {DataType} options.type The data type.\n   * @param {Uint8Array} [options.validity] Validity bitmap buffer\n   * @param {Uint8Array} options.values Values buffer\n   * @param {Uint8Array[]} options.data View data buffers\n   */\n  constructor({ data, ...options }) {\n    super(options);\n    this.data = data;\n  }\n\n  /**\n   * Get the binary data at the provided index.\n   * @param {number} index The value index.\n   * @returns {Uint8Array}\n   */\n  view(index) {\n    const { values, data } = this;\n    const offset = index << 4; // each entry is 16 bytes\n    let start = offset + 4;\n    let buf = /** @type {Uint8Array} */ (values);\n    const length = readInt32(buf, offset);\n    if (length > 12) {\n      // longer strings are in a data buffer\n      start = readInt32(buf, offset + 12);\n      buf = data[readInt32(buf, offset + 8)];\n    }\n    return buf.subarray(start, start + length);\n  }\n}\n\n/**\n * A batch of binary blobs from variable data buffers, returned as byte\n * buffers of unsigned 8-bit integers.\n * @extends {ViewBatch<Uint8Array>}\n */\nexport class BinaryViewBatch extends ViewBatch {\n  /**\n   * @param {number} index The value index.\n   */\n  value(index) {\n    return this.view(index);\n  }\n}\n\n/**\n * A batch of UTF-8 strings from variable data buffers.\n * @extends {ViewBatch<string>}\n */\nexport class Utf8ViewBatch extends ViewBatch {\n  /**\n   * @param {number} index The value index.\n   */\n  value(index) {\n    return decodeUtf8(this.view(index));\n  }\n}\n","/**\n * @import { Batch } from './batch.js'\n * @import { DataType, ValueArray } from './types.js'\n */\nimport { bisect } from './util/arrays.js';\nimport { isDirectBatch } from './batch.js';\n\n/**\n * Build up a column from batches.\n */\nexport function columnBuilder(type) {\n  let data = [];\n  return {\n    add(batch) { data.push(batch); return this; },\n    clear: () => data = [],\n    done: () => new Column(data, type)\n  };\n}\n\n/**\n * A data column. A column provides a view over one or more value batches,\n * each drawn from an Arrow record batch. This class supports random access\n * to column values by integer index; however, extracting arrays using\n * `toArray()` or iterating over values (`for (const value of column) {...}`)\n * provide more efficient ways for bulk access or scanning.\n * @template T\n */\nexport class Column {\n  /**\n   * Create a new column instance.\n   * @param {Batch<T>[]} data The value batches.\n   * @param {DataType} [type] The column data type.\n   *  If not specified, the type is extracted from the batches.\n   */\n  constructor(data, type = data[0]?.type) {\n    /**\n     * The column data type.\n     * @type {DataType}\n     * @readonly\n     */\n    this.type = type;\n    /**\n     * The column length.\n     * @type {number}\n     * @readonly\n     */\n    this.length = data.reduce((m, c) => m + c.length, 0);\n    /**\n     * The count of null values in the column.\n     * @type {number}\n     * @readonly\n     */\n    this.nullCount = data.reduce((m, c) => m + c.nullCount, 0);\n    /**\n     * An array of column data batches.\n     * @type {readonly Batch<T>[]}\n     * @readonly\n     */\n    this.data = data;\n\n    const n = data.length;\n    const offsets = new Int32Array(n + 1);\n    if (n === 1) {\n      const [ batch ] = data;\n      offsets[1] = batch.length;\n      // optimize access to single batch\n      this.at = index => batch.at(index);\n    } else {\n      for (let i = 0, s = 0; i < n; ++i) {\n        offsets[i + 1] = (s += data[i].length);\n      }\n    }\n\n    /**\n     * Index offsets for data batches.\n     * Used to map a column row index to a batch-specific index.\n     * @type {Int32Array}\n     * @readonly\n     */\n    this.offsets = offsets;\n  }\n\n  /**\n   * Provide an informative object string tag.\n   */\n  get [Symbol.toStringTag]() {\n    return 'Column';\n  }\n\n  /**\n   * Return an iterator over the values in this column.\n   * @returns {Iterator<T?>}\n   */\n  [Symbol.iterator]() {\n    const data = this.data;\n    return data.length === 1\n      ? data[0][Symbol.iterator]()\n      : batchedIterator(data);\n  }\n\n  /**\n   * Return the column value at the given index. If a column has multiple\n   * batches, this method performs binary search over the batch lengths to\n   * determine the batch from which to retrieve the value. The search makes\n   * lookup less efficient than a standard array access. If making a full\n   * scan of a column, consider extracting arrays via `toArray()` or using an\n   * iterator (`for (const value of column) {...}`).\n   * @param {number} index The row index.\n   * @returns {T | null} The value.\n   */\n  at(index) {\n    // NOTE: if there is only one batch, this method is replaced with an\n    // optimized version in the Column constructor.\n    const { data, offsets } = this;\n    const i = bisect(offsets, index) - 1;\n    return data[i]?.at(index - offsets[i]); // undefined if out of range\n  }\n\n  /**\n   * Return the column value at the given index. This method is the same as\n   * `at()` and is provided for better compatibility with Apache Arrow JS.\n   * @param {number} index The row index.\n   * @returns {T | null} The value.\n   */\n  get(index) {\n    return this.at(index);\n  }\n\n  /**\n   * Extract column values into a single array instance. When possible,\n   * a zero-copy subarray of the input Arrow data is returned.\n   * @returns {ValueArray<T?>}\n   */\n  toArray() {\n    const { length, nullCount, data } = this;\n    const copy = !nullCount && isDirectBatch(data[0]);\n    const n = data.length;\n\n    if (copy && n === 1) {\n      // use batch array directly\n      // @ts-ignore\n      return data[0].values;\n    }\n\n    // determine output array type\n    const ArrayType = !n || nullCount > 0 ? Array\n      // @ts-ignore\n      : (data[0].constructor.ArrayType ?? data[0].values.constructor);\n\n    const array = new ArrayType(length);\n    return copy ? copyArray(array, data) : extractArray(array, data);\n  }\n\n  /**\n   * Return an array of cached column values.\n   * Used internally to accelerate dictionary types.\n   */\n  cache() {\n    return this._cache ?? (this._cache = this.toArray());\n  }\n}\n\nfunction *batchedIterator(data) {\n  for (let i = 0; i < data.length; ++i) {\n    const iter = data[i][Symbol.iterator]();\n    for (let next = iter.next(); !next.done; next = iter.next()) {\n      yield next.value;\n    }\n  }\n}\n\nfunction copyArray(array, data) {\n  for (let i = 0, offset = 0; i < data.length; ++i) {\n    const { values } = data[i];\n    array.set(values, offset);\n    offset += values.length;\n  }\n  return array;\n}\n\nfunction extractArray(array, data) {\n  let index = -1;\n  for (let i = 0; i < data.length; ++i) {\n    const batch = data[i];\n    for (let j = 0; j < batch.length; ++j) {\n      array[++index] = batch.at(j);\n    }\n  }\n  return array;\n}\n","/**\n * @import { Column } from './column.js'\n * @import { Schema, StructFactory, TypeMap, ValueArray } from './types.js'\n */\nimport { bisect } from './util/arrays.js';\nimport { objectFactory, proxyFactory } from './util/struct.js';\n\n/**\n * A table consists of a collection of named columns (or 'children').\n * To work with table data directly in JavaScript, use `toColumns()`\n * to extract an object that maps column names to extracted value arrays,\n * or `toArray()` to extract an array of row objects. For random access\n * by row index, use `getChild()` to access data for a specific column.\n * @template {TypeMap} [T=TypeMap]\n */\nexport class Table {\n  /**\n   * Create a new table with the given schema and columns (children).\n   * @param {Schema} schema The table schema.\n   * @param {Column[]} children The table columns.\n   * @param {boolean} [useProxy=false] Flag indicating if row proxy\n   *  objects should be used to represent table rows (default `false`).\n   */\n  constructor(schema, children, useProxy = false) {\n    const names = schema.fields.map(f => f.name);\n\n    /**\n     * @type {Schema}\n     * @readonly\n     */\n    this.schema = schema;\n    /**\n     * @type {(keyof T)[]}\n     * @readonly\n     */\n    this.names = names;\n    /**\n     * @type {Column[]}\n     * @readonly\n     */\n    this.children = children;\n    /**\n     * @type {StructFactory}\n     * @readonly\n     */\n    this.factory = useProxy ? proxyFactory : objectFactory;\n\n    // lazily created row object generators\n    const gen = [];\n\n    /**\n     * Returns a row object generator for the given batch index.\n     * @private\n     * @readonly\n     * @param {number} b The batch index.\n     * @returns {(index: number) => { [P in keyof T]: T[P] }}\n     */\n    this.getFactory = b => gen[b]\n      ?? (gen[b] = this.factory(names, children.map(c => c.data[b])));\n  }\n\n  /**\n   * Provide an informative object string tag.\n   */\n  get [Symbol.toStringTag]() {\n    return 'Table';\n  }\n\n  /**\n   * The number of columns in this table.\n   * @return {number} The number of columns.\n   */\n  get numCols() {\n    return this.names.length;\n  }\n\n  /**\n   * The number of rows in this table.\n   * @return {number} The number of rows.\n   */\n  get numRows() {\n    return this.children[0]?.length ?? 0;\n  }\n\n  /**\n   * Return the child column at the given index position.\n   * @template {T[keyof T]} R\n   * @param {number} index The column index.\n   * @returns {Column<R>}\n   */\n  getChildAt(index) {\n    return this.children[index];\n  }\n\n  /**\n   * Return the first child column with the given name.\n   * @template {keyof T} P\n   * @param {P} name The column name.\n   * @returns {Column<T[P]>}\n   */\n  getChild(name) {\n    const i = this.names.findIndex(x => x === name);\n    return i > -1 ? this.children[i] : undefined;\n  }\n\n  /**\n   * Construct a new table containing only columns at the specified indices.\n   * The order of columns in the new table matches the order of input indices.\n   * @template {T[keyof T]} V\n   * @param {number[]} indices The indices of columns to keep.\n   * @param {string[]} [as] Optional new names for selected columns.\n   * @returns {Table<{ [key: string]: V }>} A new table with selected columns.\n   */\n  selectAt(indices, as = []) {\n    const { children, factory, schema } = this;\n    const { fields } = schema;\n    return new Table(\n      {\n        ...schema,\n        fields: indices.map((i, j) => renameField(fields[i], as[j]))\n      },\n      indices.map(i => children[i]),\n      factory === proxyFactory\n    );\n  }\n\n  /**\n   * Construct a new table containing only columns with the specified names.\n   * If columns have duplicate names, the first (with lowest index) is used.\n   * The order of columns in the new table matches the order of input names.\n   * @template {keyof T} K\n   * @param {K[]} names Names of columns to keep.\n   * @param {string[]} [as] Optional new names for selected columns.\n   * @returns A new table with columns matching the specified names.\n   */\n  select(names, as) {\n    const all = /** @type {K[]} */(this.names);\n    const indices = names.map(name => all.indexOf(name));\n    return this.selectAt(indices, as);\n  }\n\n  /**\n   * Return an object mapping column names to extracted value arrays.\n   * @returns {{ [P in keyof T]: ValueArray<T[P]> }}\n   */\n  toColumns() {\n    const { children, names } = this;\n    /** @type {{ [P in keyof T]: ValueArray<T[P]> }} */\n    // @ts-expect-error assign to empty object\n    const cols = {};\n    names.forEach((name, i) => cols[name] = children[i]?.toArray() ?? [] );\n    return cols;\n  }\n\n  /**\n   * Return an array of objects representing the rows of this table.\n   * @returns {{ [P in keyof T]: T[P] }[]}\n   */\n  toArray() {\n    const { children, getFactory, numRows } = this;\n    const data = children[0]?.data ?? [];\n    const output = Array(numRows);\n    for (let b = 0, row = -1; b < data.length; ++b) {\n      const f = getFactory(b);\n      for (let i = 0; i < data[b].length; ++i) {\n        output[++row] = f(i);\n      }\n    }\n    return output;\n  }\n\n  /**\n   * Return an iterator over objects representing the rows of this table.\n   * @returns {Generator<{ [P in keyof T]: T[P] }, any, any>}\n   */\n  *[Symbol.iterator]() {\n    const { children, getFactory } = this;\n    const data = children[0]?.data ?? [];\n    for (let b = 0; b < data.length; ++b) {\n      const f = getFactory(b);\n      for (let i = 0; i < data[b].length; ++i) {\n        yield f(i);\n      }\n    }\n  }\n\n  /**\n   * Return a row object for the given index.\n   * @param {number} index The row index.\n   * @returns {{ [P in keyof T]: T[P] }} The row object.\n   */\n  at(index) {\n    const { children, getFactory, numRows } = this;\n    if (index < 0 || index >= numRows) return null;\n    const [{ offsets }] = children;\n    const b = bisect(offsets, index) - 1;\n    return getFactory(b)(index - offsets[b]);\n  }\n\n  /**\n   * Return a row object for the given index. This method is the same as\n   * `at()` and is provided for better compatibility with Apache Arrow JS.\n   * @param {number} index The row index.\n   * @returns {{ [P in keyof T]: T[P] }} The row object.\n   */\n  get(index) {\n    return this.at(index);\n  }\n}\n\nfunction renameField(field, name) {\n  return (name != null && name !== field.name)\n    ? { ...field, name }\n    : field;\n}\n","/**\n * @import { DataType, ExtractionOptions } from './types.js';\n */\nimport { BinaryBatch, BinaryViewBatch, BoolBatch, DateBatch, DateDayBatch, DateDayMillisecondBatch, Decimal32NumberBatch, DecimalBigIntBatch, DecimalNumberBatch, DenseUnionBatch, DictionaryBatch, DirectBatch, FixedBinaryBatch, FixedListBatch, Float16Batch, Int64Batch, IntervalDayTimeBatch, IntervalMonthDayNanoBatch, LargeBinaryBatch, LargeListBatch, LargeListViewBatch, LargeUtf8Batch, ListBatch, ListViewBatch, MapBatch, MapEntryBatch, NullBatch, RunEndEncodedBatch, SparseUnionBatch, StructBatch, StructProxyBatch, TimestampMicrosecondBatch, TimestampMillisecondBatch, TimestampNanosecondBatch, TimestampSecondBatch, Utf8Batch, Utf8ViewBatch } from './batch.js';\nimport { DateUnit, IntervalUnit, TimeUnit, Type } from './constants.js';\nimport { invalidDataType } from './data-types.js';\n\n/**\n * Return a batch constructor for the given data type and extraction options.\n * @param {DataType} type The data type.\n * @param {ExtractionOptions} options The extraction options.\n */\nexport function batchType(type, options = {}) {\n  const { typeId, bitWidth, mode, precision, unit } = /** @type {any} */(type);\n  const { useBigInt, useDate, useDecimalInt, useMap, useProxy } = options;\n\n  switch (typeId) {\n    case Type.Null: return NullBatch;\n    case Type.Bool: return BoolBatch;\n    case Type.Int:\n    case Type.Time:\n    case Type.Duration:\n      return useBigInt || bitWidth < 64 ? DirectBatch : Int64Batch;\n    case Type.Float:\n      return precision ? DirectBatch : Float16Batch;\n    case Type.Date:\n      return wrap(\n        unit === DateUnit.DAY ? DateDayBatch : DateDayMillisecondBatch,\n        useDate && DateBatch\n      );\n    case Type.Timestamp:\n      return wrap(\n        unit === TimeUnit.SECOND ? TimestampSecondBatch\n          : unit === TimeUnit.MILLISECOND ? TimestampMillisecondBatch\n          : unit === TimeUnit.MICROSECOND ? TimestampMicrosecondBatch\n          : TimestampNanosecondBatch,\n        useDate && DateBatch\n      );\n    case Type.Decimal:\n      return bitWidth === 32\n        ? (useDecimalInt ? DirectBatch : Decimal32NumberBatch)\n        : (useDecimalInt ? DecimalBigIntBatch : DecimalNumberBatch);\n    case Type.Interval:\n      return unit === IntervalUnit.DAY_TIME ? IntervalDayTimeBatch\n        : unit === IntervalUnit.YEAR_MONTH ? DirectBatch\n        : IntervalMonthDayNanoBatch;\n    case Type.FixedSizeBinary: return FixedBinaryBatch;\n    case Type.Utf8: return Utf8Batch;\n    case Type.LargeUtf8: return LargeUtf8Batch;\n    case Type.Binary: return BinaryBatch;\n    case Type.LargeBinary: return LargeBinaryBatch;\n    case Type.BinaryView: return BinaryViewBatch;\n    case Type.Utf8View: return Utf8ViewBatch;\n    case Type.List: return ListBatch;\n    case Type.LargeList: return LargeListBatch;\n    case Type.Map: return useMap ? MapBatch : MapEntryBatch;\n    case Type.ListView: return ListViewBatch;\n    case Type.LargeListView: return LargeListViewBatch;\n    case Type.FixedSizeList: return FixedListBatch;\n    case Type.Struct: return useProxy ? StructProxyBatch : StructBatch;\n    case Type.RunEndEncoded: return RunEndEncodedBatch;\n    case Type.Dictionary: return DictionaryBatch;\n    case Type.Union: return mode ? DenseUnionBatch : SparseUnionBatch;\n  }\n  throw new Error(invalidDataType(typeId));\n}\n\nfunction wrap(BaseClass, WrapperClass) {\n  return WrapperClass\n    ? class WrapBatch extends WrapperClass {\n        constructor(options) {\n          super(new BaseClass(options));\n        }\n      }\n    : BaseClass;\n}\n","/**\n * @import { Sink } from './sink.js';\n */\nimport { grow } from '../util/arrays.js';\nimport { SIZEOF_INT, SIZEOF_SHORT, readInt16 } from '../util/read.js';\nimport { encodeUtf8 } from '../util/strings.js';\n\nexport function writeInt32(buf, index, value) {\n  buf[index] = value;\n  buf[index + 1] = value >> 8;\n  buf[index + 2] = value >> 16;\n  buf[index + 3] = value >> 24;\n}\n\nexport function writeInt64(buf, index, value) {\n  const v = BigInt(value);\n  writeInt32(buf, index + 4, Number(BigInt.asIntN(32, v >> BigInt(32))));\n  writeInt32(buf, index + 0, Number(BigInt.asIntN(32, v)));\n}\n\nconst INIT_SIZE = 1024;\n\n/** Flatbuffer binary builder. */\nexport class Builder {\n  /**\n   * Create a new builder instance.\n   * @param {Sink} sink The byte consumer.\n   */\n  constructor(sink) {\n    /**\n     * Sink that consumes built byte buffers.\n     * @type {Sink}\n     */\n    this.sink = sink;\n    /**\n     * Minimum alignment encountered so far.\n     * @type {number}\n     */\n    this.minalign = 1;\n    /**\n     * Current byte buffer.\n     * @type {Uint8Array}\n     */\n    this.buf = new Uint8Array(INIT_SIZE);\n    /**\n     * Remaining space in the current buffer.\n     * @type {number}\n     */\n    this.space = INIT_SIZE;\n    /**\n     * List of offsets of all vtables. Used to find and\n     * reuse tables upon duplicated table field schemas.\n     * @type {number[]}\n     */\n    this.vtables = [];\n    /**\n     * Total bytes written to sink thus far.\n     */\n    this.outputBytes = 0;\n  }\n\n  /**\n   * Returns the flatbuffer offset, relative to the end of the current buffer.\n   * @returns {number} Offset relative to the end of the buffer.\n   */\n  offset() {\n    return this.buf.length - this.space;\n  }\n\n  /**\n   * Write a flatbuffer int8 value at the current buffer position\n   * and advance the internal cursor.\n   * @param {number} value\n   */\n  writeInt8(value) {\n    this.buf[this.space -= 1] = value;\n  }\n\n  /**\n   * Write a flatbuffer int16 value at the current buffer position\n   * and advance the internal cursor.\n   * @param {number} value\n   */\n  writeInt16(value) {\n    this.buf[this.space -= 2] = value;\n    this.buf[this.space + 1] = value >> 8;\n  }\n\n  /**\n   * Write a flatbuffer int32 value at the current buffer position\n   * and advance the internal cursor.\n   * @param {number} value\n   */\n  writeInt32(value) {\n    writeInt32(this.buf, this.space -= 4, value);\n  }\n\n  /**\n   * Write a flatbuffer int64 value at the current buffer position\n   * and advance the internal cursor.\n   * @param {number} value\n   */\n  writeInt64(value) {\n    writeInt64(this.buf, this.space -= 8, value);\n  }\n\n  /**\n   * Add a flatbuffer int8 value, properly aligned,\n   * @param value The int8 value to add the buffer.\n   */\n  addInt8(value) {\n    prep(this, 1, 0);\n    this.writeInt8(value);\n  }\n\n  /**\n   * Add a flatbuffer int16 value, properly aligned,\n   * @param value The int16 value to add the buffer.\n   */\n  addInt16(value) {\n    prep(this, 2, 0);\n    this.writeInt16(value);\n  }\n\n  /**\n   * Add a flatbuffer int32 value, properly aligned,\n   * @param value The int32 value to add the buffer.\n   */\n  addInt32(value) {\n    prep(this, 4, 0);\n    this.writeInt32(value);\n  }\n\n  /**\n   * Add a flatbuffer int64 values, properly aligned.\n   * @param value The int64 value to add the buffer.\n   */\n  addInt64(value) {\n    prep(this, 8, 0);\n    this.writeInt64(value);\n  }\n\n  /**\n   * Add a flatbuffer offset, relative to where it will be written.\n   * @param {number} offset The offset to add.\n   */\n  addOffset(offset) {\n    prep(this, SIZEOF_INT, 0); // Ensure alignment is already done.\n    this.writeInt32(this.offset() - offset + SIZEOF_INT);\n  }\n\n  /**\n   * Add a flatbuffer object (vtable).\n   * @param {number} numFields The maximum number of fields\n   *  this object may include.\n   * @param {(tableBuilder: ReturnType<objectBuilder>) => void} [addFields]\n   *  A callback function that writes all fields using an object builder.\n   * @returns {number} The object offset.\n   */\n  addObject(numFields, addFields) {\n    const b = objectBuilder(this, numFields);\n    addFields?.(b);\n    return b.finish();\n  }\n\n  /**\n   * Add a flatbuffer vector (list).\n   * @template T\n   * @param {T[]} items An array of items to write.\n   * @param {number} itemSize The size in bytes of a serialized item.\n   * @param {number} alignment The desired byte alignment value.\n   * @param {(builder: this, item: T) => void} writeItem A callback\n   *  function that writes a vector item to this builder.\n   * @returns {number} The vector offset.\n   */\n  addVector(items, itemSize, alignment, writeItem) {\n    const n = items?.length;\n    if (!n) return 0;\n    prep(this, SIZEOF_INT, itemSize * n);\n    prep(this, alignment, itemSize * n); // Just in case alignment > int.\n    for (let i = n; --i >= 0;) {\n      writeItem(this, items[i]);\n    }\n    this.writeInt32(n);\n    return this.offset();\n  }\n\n  /**\n   * Convenience method for writing a vector of byte buffer offsets.\n   * @param {number[]} offsets\n   * @returns {number} The vector offset.\n   */\n  addOffsetVector(offsets) {\n    return this.addVector(offsets, 4, 4, (b, off) => b.addOffset(off));\n  }\n\n  /**\n   * Add a flatbuffer UTF-8 string.\n   * @param {string} s The string to encode.\n   * @return {number} The string offset.\n   */\n  addString(s) {\n    if (s == null) return 0;\n    const utf8 = encodeUtf8(s);\n    const n = utf8.length;\n    this.addInt8(0); // string null terminator\n    prep(this, SIZEOF_INT, n);\n    this.buf.set(utf8, this.space -= n);\n    this.writeInt32(n);\n    return this.offset();\n  }\n\n  /**\n   * Finish the current flatbuffer by adding a root offset.\n   * @param {number} rootOffset The root offset.\n   */\n  finish(rootOffset) {\n    prep(this, this.minalign, SIZEOF_INT);\n    this.addOffset(rootOffset);\n  }\n\n  /**\n   * Flush the current flatbuffer byte buffer content to the sink,\n   * and reset the flatbuffer builder state.\n   */\n  flush() {\n    const { buf, sink } = this;\n    const bytes = buf.subarray(this.space, buf.length);\n    sink.write(bytes);\n    this.outputBytes += bytes.byteLength;\n    this.minalign = 1;\n    this.vtables = [];\n    this.buf = new Uint8Array(INIT_SIZE);\n    this.space = INIT_SIZE;\n  }\n\n  /**\n   * Add a byte buffer directly to the builder sink. This method bypasses\n   * any unflushed flatbuffer state and leaves it unchanged, writing the\n   * buffer to the sink *before* the flatbuffer.\n   * The buffer will be padded for 64-bit (8-byte) alignment as needed.\n   * @param {Uint8Array} buffer The buffer to add.\n   * @returns {number} The total byte count of the buffer and padding.\n   */\n  addBuffer(buffer) {\n    const size = buffer.byteLength;\n    if (!size) return 0;\n    this.sink.write(buffer);\n    this.outputBytes += size;\n    const pad = ((size + 7) & ~7) - size;\n    this.addPadding(pad);\n    return size + pad;\n  }\n\n  /**\n   * Write padding bytes directly to the builder sink. This method bypasses\n   * any unflushed flatbuffer state and leaves it unchanged, writing the\n   * padding bytes to the sink *before* the flatbuffer.\n   * @param {number} byteCount The number of padding bytes.\n   */\n  addPadding(byteCount) {\n    if (byteCount > 0) {\n      this.sink.write(new Uint8Array(byteCount));\n      this.outputBytes += byteCount;\n    }\n  }\n}\n\n/**\n * Prepare to write an element of `size` after `additionalBytes` have been\n * written, e.g. if we write a string, we need to align such the int length\n * field is aligned to 4 bytes, and the string data follows it directly. If all\n * we need to do is alignment, `additionalBytes` will be 0.\n * @param {Builder} builder The builder to prep.\n * @param {number} size The size of the new element to write.\n * @param {number} additionalBytes Additional padding size.\n */\nexport function prep(builder, size, additionalBytes) {\n  let { buf, space, minalign } = builder;\n\n  // track the biggest thing we've ever aligned to\n  if (size > minalign) {\n    builder.minalign = size;\n  }\n\n  // find alignment needed so that `size` aligns after `additionalBytes`\n  const bufSize = buf.length;\n  const used = bufSize - space + additionalBytes;\n  const alignSize = (~used + 1) & (size - 1);\n\n  // reallocate the buffer if needed\n  buf = grow(buf, used + alignSize + size - 1, true);\n  space += buf.length - bufSize;\n\n  // add padding\n  for (let i = 0; i < alignSize; ++i) {\n    buf[--space] = 0;\n  }\n\n  // update builder state\n  builder.buf = buf;\n  builder.space = space;\n}\n\n/**\n * Returns a builder object for flatbuffer objects (vtables).\n * @param {Builder} builder The underlying flatbuffer builder.\n * @param {number} numFields The expected number of fields, not\n *  including the standard size fields.\n */\nfunction objectBuilder(builder, numFields) {\n  /** @type {number[]} */\n  const vtable = Array(numFields).fill(0);\n  const startOffset = builder.offset();\n\n  function slot(index) {\n    vtable[index] = builder.offset();\n  }\n\n  return {\n    /**\n     * Add an int8-valued table field.\n     * @param {number} index\n     * @param {number} value\n     * @param {number} defaultValue\n     */\n    addInt8(index, value, defaultValue) {\n      if (value != defaultValue) {\n        builder.addInt8(value);\n        slot(index);\n      }\n    },\n\n    /**\n     * Add an int16-valued table field.\n     * @param {number} index\n     * @param {number} value\n     * @param {number} defaultValue\n     */\n    addInt16(index, value, defaultValue) {\n      if (value != defaultValue) {\n        builder.addInt16(value);\n        slot(index);\n      }\n    },\n\n    /**\n     * Add an int32-valued table field.\n     * @param {number} index\n     * @param {number} value\n     * @param {number} defaultValue\n     */\n    addInt32(index, value, defaultValue) {\n      if (value != defaultValue) {\n        builder.addInt32(value);\n        slot(index);\n      }\n    },\n\n    /**\n     * Add an int64-valued table field.\n     * @param {number} index\n     * @param {number} value\n     * @param {number} defaultValue\n     */\n    addInt64(index, value, defaultValue) {\n      if (value != defaultValue) {\n        builder.addInt64(value);\n        slot(index);\n      }\n    },\n\n    /**\n     * Add a buffer offset-valued table field.\n     * @param {number} index\n     * @param {number} value\n     * @param {number} defaultValue\n     */\n    addOffset(index, value, defaultValue) {\n      if (value != defaultValue) {\n        builder.addOffset(value);\n        slot(index);\n      }\n    },\n\n    /**\n     * Write the vtable to the buffer and return the table offset.\n     * @returns {number} The buffer offset to the vtable.\n     */\n    finish() {\n      // add offset entry, will overwrite later with actual offset\n      builder.addInt32(0);\n      const vtableOffset = builder.offset();\n\n      // trim zero-valued fields (indicating default value)\n      let i = numFields;\n      while (--i >= 0 && vtable[i] === 0) {} // eslint-disable-line no-empty\n      const size = i + 1;\n\n      // Write out the current vtable.\n      for (; i >= 0; --i) {\n        // Offset relative to the start of the table.\n        builder.addInt16(vtable[i] ? (vtableOffset - vtable[i]) : 0);\n      }\n\n      const standardFields = 2; // size fields\n      builder.addInt16(vtableOffset - startOffset);\n      const len = (size + standardFields) * SIZEOF_SHORT;\n      builder.addInt16(len);\n\n      // Search for an existing vtable that matches the current one.\n      let existingTable = 0;\n      const { buf, vtables, space: vt1 } = builder;\n    outer_loop:\n      for (i = 0; i < vtables.length; ++i) {\n        const vt2 = buf.length - vtables[i];\n        if (len == readInt16(buf, vt2)) {\n          for (let j = SIZEOF_SHORT; j < len; j += SIZEOF_SHORT) {\n            if (readInt16(buf, vt1 + j) != readInt16(buf, vt2 + j)) {\n              continue outer_loop;\n            }\n          }\n          existingTable = vtables[i];\n          break;\n        }\n      }\n\n      if (existingTable) {\n        // Found a match: remove the current vtable.\n        // Point table to existing vtable.\n        builder.space = buf.length - vtableOffset;\n        writeInt32(buf, builder.space, existingTable - vtableOffset);\n      } else {\n        // No match: add the location of the current vtable to the vtables list.\n        // Point table to current vtable.\n        const off = builder.offset();\n        vtables.push(off);\n        writeInt32(buf, buf.length - vtableOffset, off - vtableOffset);\n      }\n\n      return vtableOffset;\n    }\n  }\n}\n","/** @import { Codec, CompressionType_ } from './types.js' */\nimport { CompressionType } from './constants.js';\nimport { writeInt64 } from './encode/builder.js';\nimport { keyFor } from './util/objects.js';\nimport { readInt64 } from './util/read.js';\n\nconst LENGTH_NO_COMPRESSED_DATA = -1;\nconst COMPRESS_LENGTH_PREFIX = 8;\n\n/**\n * Return an error message for a missing codec.\n * @param {CompressionType_} type The codec type.\n */\nexport function missingCodec(type) {\n  return `Missing compression codec \"${keyFor(CompressionType, type)}\" (id ${type})`;\n}\n\n/** @type {Map<CompressionType_, Codec>} */\nconst codecs = new Map;\n\n/**\n * Register a codec to use for compressing or decompressing Arrow buffers.\n * @param {CompressionType_} type The compression type.\n * @param {Codec} codec The codec implementation.\n */\nexport function setCompressionCodec(type, codec) {\n  codecs.set(type, codec);\n}\n\n/**\n * Returns a compression codec for the provided type, or null if not found.\n * Compression codecs must first be registered using *setCompressionCodec*.\n * @param {CompressionType_ | null} [type] The compression type.\n * @returns {Codec | null} The compression codec, or null if not registered.\n */\nexport function getCompressionCodec(type) {\n  return (type != null && codecs.get(type)) || null;\n}\n\n/**\n * Decompress an Arrow buffer, return decompressed bytes and region metadata.\n * @param {Uint8Array} body The message body.\n * @param {{ offset: number, length: number }} region Buffer region metadata.\n * @param {Codec} codec A compression codec.\n * @returns {{ bytes: Uint8Array, offset: number, length: number }}\n */\nexport function decompressBuffer(body, { offset, length }, codec) {\n  if (length === 0) {\n    return { bytes: new Uint8Array(0), offset: 0, length: 0 };\n  }\n  const ulen = readInt64(body, offset); // uncompressed length\n  const buf = body.subarray(offset + COMPRESS_LENGTH_PREFIX, offset + length);\n  const bytes = (ulen === LENGTH_NO_COMPRESSED_DATA) ? buf : codec.decode(buf);\n  return { bytes, offset: 0, length: bytes.length };\n}\n\n/**\n * Compress an Arrow buffer, return encoded bytes. If the compression does\n * not decrease the overall length, retains uncompressed bytes.\n * @param {Uint8Array} bytes The byte buffer to compress.\n * @param {Codec} codec A compression codec.\n */\nexport function compressBuffer(bytes, codec) {\n  const compressed = codec.encode(bytes);\n  const keep = compressed.length < bytes.length;\n  const data = keep ? compressed : bytes;\n  const buf = new Uint8Array(COMPRESS_LENGTH_PREFIX + data.length);\n  writeInt64(buf, 0, keep ? bytes.length : LENGTH_NO_COMPRESSED_DATA);\n  buf.set(data, COMPRESS_LENGTH_PREFIX);\n  return buf;\n}\n","import { readInt32, readInt64, readVector } from '../util/read.js';\n\n/**\n * Decode a block that points to messages within an Arrow 'file' format.\n * @param {Uint8Array} buf A byte buffer of binary Arrow IPC data\n * @param {number} index The starting index in the byte buffer\n * @returns The file block.\n */\nexport function decodeBlock(buf, index) {\n  //  0: offset\n  //  8: metadataLength\n  // 16: bodyLength\n  return {\n    offset: readInt64(buf, index),\n    metadataLength: readInt32(buf, index + 8),\n    bodyLength: readInt64(buf, index + 16)\n  }\n}\n\n/**\n * Decode a vector of blocks.\n * @param {Uint8Array} buf\n * @param {number} index\n * @returns An array of file blocks.\n */\nexport function decodeBlocks(buf, index) {\n  return readVector(buf, index, 24, decodeBlock);\n}\n","/**\n * @import { BodyCompression, BodyCompressionMethod_, CompressionType_ } from '../types.js'\n */\nimport { BodyCompressionMethod, CompressionType } from '../constants.js';\nimport { readInt8, readObject } from '../util/read.js';\n\n/**\n * Decode record batch body compression metadata.\n * @param {Uint8Array} buf A byte buffer of binary Arrow IPC data\n * @param {number} index The starting index in the byte buffer\n * @returns {BodyCompression | undefined} The body compression metadata\n */\nexport function decodeBodyCompression(buf, index) {\n  //  4: codec\n  //  6: method\n  const get = readObject(buf, index);\n  return {\n    codec: /** @type {CompressionType_} */(\n      get(4, readInt8, CompressionType.LZ4_FRAME)),\n    method: /** @type {BodyCompressionMethod_} */(\n      get(6, readInt8, BodyCompressionMethod.BUFFER))\n  };\n}\n","/**\n * @import { RecordBatch, Version_ } from '../types.js'\n */\nimport { Version } from '../constants.js';\nimport { readInt64, readObject, readOffset, readVector } from '../util/read.js';\nimport { decodeBodyCompression } from './body-compression.js';\n\n/**\n * Decode a record batch.\n * @param {Uint8Array} buf A byte buffer of binary Arrow IPC data\n * @param {number} index The starting index in the byte buffer\n * @param {Version_} version Arrow version value\n * @returns {RecordBatch} The record batch\n */\nexport function decodeRecordBatch(buf, index, version) {\n  //  4: length\n  //  6: nodes\n  //  8: buffers\n  // 10: compression (requires codec plug-in)\n  // 12: variadicBuffers (buffer counts for view-typed fields)\n  const get = readObject(buf, index);\n\n  // If an Arrow buffer was written before version 4,\n  // advance 8 bytes to skip the now-removed page_id field\n  const offset = version < Version.V4 ? 8 : 0;\n\n  return {\n    length: get(4, readInt64, 0),\n    nodes: readVector(buf, get(6, readOffset), 16, (buf, pos) => ({\n      length: readInt64(buf, pos),\n      nullCount: readInt64(buf, pos + 8)\n    })),\n    regions: readVector(buf, get(8, readOffset), 16 + offset, (buf, pos) => ({\n      offset: readInt64(buf, pos + offset),\n      length: readInt64(buf, pos + offset + 8)\n    })),\n    compression: get(10, decodeBodyCompression),\n    variadic: readVector(buf, get(12, readOffset), 8, readInt64)\n  };\n}\n","/**\n * @import { DictionaryBatch, Version_ } from '../types.js'\n */\nimport { readBoolean, readInt64, readObject } from '../util/read.js';\nimport { decodeRecordBatch } from './record-batch.js';\n\n/**\n * Decode a dictionary batch.\n * @param {Uint8Array} buf A byte buffer of binary Arrow IPC data\n * @param {number} index The starting index in the byte buffer\n * @param {Version_} version Arrow version value\n * @returns {DictionaryBatch} The dictionary batch\n */\nexport function decodeDictionaryBatch(buf, index, version) {\n  //  4: id\n  //  6: data\n  //  8: isDelta\n  const get = readObject(buf, index);\n  return {\n    id: get(4, readInt64, 0),\n    data: get(6, (buf, off) => decodeRecordBatch(buf, off, version)),\n    /**\n     * If isDelta is true the values in the dictionary are to be appended to a\n     * dictionary with the indicated id. If isDelta is false this dictionary\n     * should replace the existing dictionary.\n     */\n    isDelta: get(8, readBoolean, false)\n  };\n}\n","/**\n * @import { DataType, Field } from '../types.js'\n */\nimport { DateUnit, IntervalUnit, Precision, TimeUnit, Type, UnionMode } from '../constants.js';\nimport { binary, date, decimal, duration, fixedSizeBinary, fixedSizeList, float, int, interval, invalidDataType, largeBinary, largeList, largeListView, largeUtf8, list, listView, mapType, runEndEncoded, struct, time, timestamp, union, utf8 } from '../data-types.js';\nimport { checkOneOf } from '../util/objects.js';\nimport { readBoolean, readInt16, readInt32, readObject, readOffset, readString, readVector } from '../util/read.js';\n\n/**\n * Decode a data type definition for a field.\n * @param {Uint8Array} buf A byte buffer of binary Arrow IPC data.\n * @param {number} index The starting index in the byte buffer.\n * @param {number} typeId The data type id.\n * @param {Field[]} [children] A list of parsed child fields.\n * @returns {DataType} The data type.\n */\nexport function decodeDataType(buf, index, typeId, children) {\n  checkOneOf(typeId, Type, invalidDataType);\n  const get = readObject(buf, index);\n\n  switch (typeId) {\n    // types without flatbuffer objects\n    case Type.Binary: return binary();\n    case Type.Utf8: return utf8();\n    case Type.LargeBinary: return largeBinary();\n    case Type.LargeUtf8: return largeUtf8();\n    case Type.List: return list(children[0]);\n    case Type.ListView: return listView(children[0]);\n    case Type.LargeList: return largeList(children[0]);\n    case Type.LargeListView: return largeListView(children[0]);\n    case Type.Struct: return struct(children);\n    case Type.RunEndEncoded: return runEndEncoded(children[0], children[1]);\n\n    // types with flatbuffer objects\n    case Type.Int: return int(\n      // @ts-ignore\n      get(4, readInt32, 0), // bitwidth\n      get(6, readBoolean, false) // signed\n    );\n    case Type.Float: return float(\n      // @ts-ignore\n      get(4, readInt16, Precision.HALF) // precision\n    );\n    case Type.Decimal: return decimal(\n      get(4, readInt32, 0), // precision\n      get(6, readInt32, 0), // scale\n      // @ts-ignore\n      get(8, readInt32, 128) // bitwidth\n    );\n    case Type.Date: return date(\n      // @ts-ignore\n      get(4, readInt16, DateUnit.MILLISECOND) // unit\n    );\n    case Type.Time: return time(\n      // @ts-ignore\n      get(4, readInt16, TimeUnit.MILLISECOND) // unit\n    );\n    case Type.Timestamp: return timestamp(\n      // @ts-ignore\n      get(4, readInt16, TimeUnit.SECOND), // unit\n      get(6, readString) // timezone\n    );\n    case Type.Interval: return interval(\n      // @ts-ignore\n      get(4, readInt16, IntervalUnit.YEAR_MONTH) // unit\n    );\n    case Type.Duration: return duration(\n      // @ts-ignore\n      get(4, readInt16, TimeUnit.MILLISECOND) // unit\n    );\n\n    case Type.FixedSizeBinary: return fixedSizeBinary(\n      get(4, readInt32, 0) // stride\n    );\n    case Type.FixedSizeList: return fixedSizeList(\n      children[0],\n      get(4, readInt32, 0), // stride\n    );\n    case Type.Map: return mapType(\n      get(4, readBoolean, false), // keysSorted\n      children[0]\n    );\n\n    case Type.Union: return union(\n      // @ts-ignore\n      get(4, readInt16, UnionMode.Sparse), // mode\n      children,\n      readVector(buf, get(6, readOffset), 4, readInt32) // type ids\n    );\n  }\n  // case Type.NONE:\n  // case Type.Null:\n  // case Type.Bool:\n  // case Type.BinaryView:\n  // case Type.Utf8View:\n  // @ts-ignore\n  return { typeId };\n}\n","/**\n * @import { Metadata } from '../types.js'\n */\nimport { readObject, readString, readVector } from '../util/read.js';\n\n/**\n * Decode custom metadata consisting of key-value string pairs.\n * @param {Uint8Array} buf A byte buffer of binary Arrow IPC data\n * @param {number} index The starting index in the byte buffer\n * @returns {Metadata | null} The custom metadata map\n */\nexport function decodeMetadata(buf, index) {\n  const entries = readVector(buf, index, 4, (buf, pos) => {\n    const get = readObject(buf, pos);\n    return /** @type {[string, string]} */ ([\n      get(4, readString), // 4: key (string)\n      get(6, readString)  // 6: key (string)\n    ]);\n  });\n  return entries.length ? new Map(entries) : null;\n}\n","/**\n * @import { DictionaryType, Endianness_, Field, IntType, Schema, Version_ } from '../types.js'\n */\nimport { Type } from '../constants.js';\nimport { dictionary, int32 } from '../data-types.js';\nimport { readBoolean, readInt16, readInt64, readObject, readOffset, readString, readUint8, readVector } from '../util/read.js';\nimport { decodeDataType } from './data-type.js';\nimport { decodeMetadata } from './metadata.js';\n\n/**\n * Decode a table schema describing the fields and their data types.\n * @param {Uint8Array} buf A byte buffer of binary Arrow IPC data\n * @param {number} index The starting index in the byte buffer\n * @param {Version_} version Arrow version value\n * @returns {Schema} The schema\n */\nexport function decodeSchema(buf, index, version) {\n  //  4: endianness (int16)\n  //  6: fields (vector)\n  //  8: metadata (vector)\n  // 10: features (int64[])\n  const get = readObject(buf, index);\n  return {\n    version,\n    endianness: /** @type {Endianness_} */ (get(4, readInt16, 0)),\n    fields: get(6, decodeSchemaFields, []),\n    metadata: get(8, decodeMetadata)\n  };\n}\n\n/**\n * @returns {Field[] | null}\n */\nfunction decodeSchemaFields(buf, fieldsOffset) {\n  return readVector(buf, fieldsOffset, 4, decodeField);\n}\n\n/**\n * @returns {Field}\n */\nfunction decodeField(buf, index) {\n  //  4: name (string)\n  //  6: nullable (bool)\n  //  8: type id (uint8)\n  // 10: type (union)\n  // 12: dictionary (table)\n  // 14: children (vector)\n  // 16: metadata (vector)\n  const get = readObject(buf, index);\n  const typeId = get(8, readUint8, Type.NONE);\n  const typeOffset = get(10, readOffset, 0);\n  const dict = get(12, decodeDictionary);\n  const children = get(14, decodeFieldChildren, []);\n\n  let type = decodeDataType(buf, typeOffset, typeId, children);\n  if (dict) {\n    dict.dictionary = type;\n    type = dict;\n  }\n\n  return {\n    name: get(4, readString),\n    type,\n    nullable: get(6, readBoolean, false),\n    metadata: get(16, decodeMetadata)\n  };\n}\n\n/**\n * @returns {Field[]}\n */\nfunction decodeFieldChildren(buf, fieldOffset) {\n  return readVector(buf, fieldOffset, 4, decodeField);\n}\n\n/**\n * @param {Uint8Array} buf\n * @param {number} index\n * @returns {DictionaryType}\n */\nfunction decodeDictionary(buf, index) {\n  if (!index) return null;\n  //  4: id (int64)\n  //  6: indexType (Int type)\n  //  8: isOrdered (boolean)\n  // 10: kind (int16) currently only dense array is supported\n  const get = readObject(buf, index);\n  return dictionary(\n    null, // data type will be populated by caller\n    get(6, decodeInt, int32()), // index type\n    get(8, readBoolean, false), // ordered\n    get(4, readInt64, 0), // id\n  );\n}\n\n/**\n * Decode an integer data type.\n * @param {Uint8Array} buf A byte buffer of binary Arrow IPC data.\n * @param {number} index The starting index in the byte buffer.\n * @returns {IntType}\n */\nfunction decodeInt(buf, index) {\n  return /** @type {IntType} */ (\n    decodeDataType(buf, index, Type.Int)\n  );\n}\n","/**\n * @import { Message, MessageHeader_, Version_ } from '../types.js'\n */\nimport { MessageHeader, Version } from '../constants.js';\nimport { keyFor } from '../util/objects.js';\nimport { SIZEOF_INT, readInt16, readInt32, readInt64, readObject, readOffset, readUint8 } from '../util/read.js';\nimport { decodeDictionaryBatch } from './dictionary-batch.js';\nimport { decodeRecordBatch } from './record-batch.js';\nimport { decodeSchema } from './schema.js';\n\nconst invalidMessageMetadata = (expected, actual) =>\n  `Expected to read ${expected} metadata bytes, but only read ${actual}.`;\n\nconst invalidMessageBodyLength = (expected, actual) =>\n  `Expected to read ${expected} bytes for message body, but only read ${actual}.`;\n\nconst invalidMessageType = (type) =>\n  `Unsupported message type: ${type} (${keyFor(MessageHeader, type)})`;\n\n/**\n * A \"message\" contains a block of Apache Arrow data, such as a schema,\n * record batch, or dictionary batch. This message decodes a single\n * message, returning its associated metadata and content.\n * @param {Uint8Array} buf A byte buffer of binary Arrow IPC data\n * @param {number} index The starting index in the byte buffer\n * @returns {Message} The decoded message.\n */\nexport function decodeMessage(buf, index) {\n  // get message start\n  let metadataLength = readInt32(buf, index) || 0;\n  index += SIZEOF_INT;\n\n  // ARROW-6313: If the first 4 bytes are continuation indicator (-1), read\n  // the next 4 for the 32-bit metadata length. Otherwise, assume this is a\n  // pre-v0.15 message, where the first 4 bytes are the metadata length.\n  if (metadataLength === -1) {\n    metadataLength = readInt32(buf, index) || 0;\n    index += SIZEOF_INT;\n  }\n  if (metadataLength === 0) return null;\n\n  const head = buf.subarray(index, index += metadataLength);\n  if (head.byteLength < metadataLength) {\n    throw new Error(invalidMessageMetadata(metadataLength, head.byteLength));\n  }\n\n  // decode message metadata\n  //  4: version\n  //  6: headerType\n  //  8: headerIndex\n  // 10: bodyLength\n  const get = readObject(head, 0);\n  const version = /** @type {Version_} */\n    (get(4, readInt16, Version.V1));\n  const type = /** @type {MessageHeader_} */\n    (get(6, readUint8, MessageHeader.NONE));\n  const offset = get(8, readOffset, 0);\n  const bodyLength = get(10, readInt64, 0);\n  let content;\n\n  if (offset) {\n    // decode message header\n    const decoder = type === MessageHeader.Schema ? decodeSchema\n      : type === MessageHeader.DictionaryBatch ? decodeDictionaryBatch\n      : type === MessageHeader.RecordBatch ? decodeRecordBatch\n      : null;\n    if (!decoder) throw new Error(invalidMessageType(type));\n    content = decoder(head, offset, version);\n\n    // extract message body\n    if (bodyLength > 0) {\n      const body = buf.subarray(index, index += bodyLength);\n      if (body.byteLength < bodyLength) {\n        throw new Error(invalidMessageBodyLength(bodyLength, body.byteLength));\n      }\n      // @ts-ignore\n      content.body = body;\n    } else if (type !== MessageHeader.Schema) {\n      // table-from-ipc.js buffer accessor requires body to exist, even for empty batches\n      // @ts-ignore\n      content.body = new Uint8Array(0);\n    }\n  }\n\n  return { version, type, index, content };\n}\n","/**\n * @import { ArrowData, Version_ } from '../types.js'\n */\nimport { MAGIC, MessageHeader, Version } from '../constants.js';\nimport { isArrayBufferLike } from '../util/arrays.js';\nimport { readInt16, readInt32, readObject } from '../util/read.js';\nimport { decodeBlocks } from './block.js';\nimport { decodeMessage } from './message.js';\nimport { decodeMetadata } from './metadata.js';\nimport { decodeSchema } from './schema.js';\n\n/**\n * Decode [Apache Arrow IPC data][1] and return parsed schema, record batch,\n * and dictionary batch definitions. The input binary data may be either\n * an `ArrayBuffer` or `Uint8Array`. For Arrow data in the IPC 'stream' format,\n * an array of `Uint8Array` instances is also supported.\n *\n * This method stops short of generating views over field buffers. Use the\n * `createData()` method on the result to enable column data access.\n *\n * [1]: https://arrow.apache.org/docs/format/Columnar.html#serialization-and-interprocess-communication-ipc\n * @param {ArrayBufferLike | Uint8Array | Uint8Array[]} data\n *  The source byte buffer, or an array of buffers. If an array, each byte\n *  array may contain one or more self-contained messages. Messages may NOT\n *  span multiple byte arrays.\n * @returns {import('../types.js').ArrowData}\n */\nexport function decodeIPC(data) {\n  const source = isArrayBufferLike(data) ? new Uint8Array(data) : data;\n  return source instanceof Uint8Array && isArrowFileFormat(source)\n    ? decodeIPCFile(source)\n    : decodeIPCStream(source);\n}\n\n/**\n * @param {Uint8Array} buf\n * @returns {boolean}\n */\nfunction isArrowFileFormat(buf) {\n  if (!buf || buf.length < 4) return false;\n  for (let i = 0; i < 6; ++i) {\n    if (MAGIC[i] !== buf[i]) return false;\n  }\n  return true;\n}\n\n/**\n * Decode data in the [Arrow IPC 'stream' format][1].\n *\n * [1]: https://arrow.apache.org/docs/format/Columnar.html#ipc-streaming-format\n * @param {Uint8Array | Uint8Array[]} data The source byte buffer, or an\n *  array of buffers. If an array, each byte array may contain one or more\n *  self-contained messages. Messages may NOT span multiple byte arrays.\n * @returns {ArrowData}\n */\nexport function decodeIPCStream(data) {\n  const stream = [data].flat();\n\n  let schema;\n  const records = [];\n  const dictionaries = [];\n\n  // consume each message in the stream\n  for (const buf of stream) {\n    if (!(buf instanceof Uint8Array)) {\n      throw new Error(`IPC data batch was not a Uint8Array.`);\n    }\n    let offset = 0;\n\n    // decode all messages in current buffer\n    while (true) {\n      const m = decodeMessage(buf, offset);\n      if (m === null) break; // end of messages\n      offset = m.index;\n      if (!m.content) continue;\n      switch (m.type) {\n        case MessageHeader.Schema:\n          // ignore repeated schema messages\n          if (!schema) schema = m.content;\n          break;\n        case MessageHeader.RecordBatch:\n          records.push(m.content);\n          break;\n        case MessageHeader.DictionaryBatch:\n          dictionaries.push(m.content);\n          break;\n      }\n    }\n  }\n\n  return /** @type {ArrowData} */ (\n    { schema, dictionaries, records, metadata: null }\n  );\n}\n\n/**\n * Decode data in the [Arrow IPC 'file' format][1].\n *\n * [1]: https://arrow.apache.org/docs/format/Columnar.html#ipc-file-format\n * @param {Uint8Array} data The source byte buffer.\n * @returns {ArrowData}\n */\nexport function decodeIPCFile(data) {\n  // find footer location\n  const offset = data.byteLength - (MAGIC.length + 4);\n  const length = readInt32(data, offset);\n\n  // decode file footer\n  //  4: version\n  //  6: schema\n  //  8: dictionaries (vector)\n  // 10: batches (vector)\n  // 12: metadata\n  const get = readObject(data, offset - length);\n  const version = /** @type {Version_} */\n    (get(4, readInt16, Version.V1));\n  const dicts = get(8, decodeBlocks, []);\n  const recs = get(10, decodeBlocks, []);\n\n  return /** @type {ArrowData} */ ({\n    schema: get(6, (buf, index) => decodeSchema(buf, index, version)),\n    dictionaries: dicts.map(({ offset }) => decodeMessage(data, offset).content),\n    records: recs.map(({ offset }) => decodeMessage(data, offset).content),\n    metadata: get(12, decodeMetadata)\n  });\n}\n","/**\n * @import { ArrowData, BodyCompression, ExtractionOptions, Field, RecordBatch, Schema } from '../types.js'\n */\nimport { batchType } from '../batch-type.js';\nimport { columnBuilder } from '../column.js';\nimport { decompressBuffer, getCompressionCodec, missingCodec } from '../compression.js';\nimport { BodyCompressionMethod, Type, UnionMode, Version } from '../constants.js';\nimport { invalidDataType } from '../data-types.js';\nimport { Table } from '../table.js';\nimport { int8Array } from '../util/arrays.js';\nimport { decodeIPC } from './decode-ipc.js';\n\n/**\n * Decode [Apache Arrow IPC data][1] and return a new Table. The input binary\n * data may be either an `ArrayBuffer` or `Uint8Array`. For Arrow data in the\n * [IPC 'stream' format][2], an array of `Uint8Array` values is also supported.\n *\n * [1]: https://arrow.apache.org/docs/format/Columnar.html#serialization-and-interprocess-communication-ipc\n * [2]: https://arrow.apache.org/docs/format/Columnar.html#ipc-streaming-format\n * @param {ArrayBufferLike | Uint8Array | Uint8Array[]} data\n *  The source byte buffer, or an array of buffers. If an array, each byte\n *  array may contain one or more self-contained messages. Messages may NOT\n *  span multiple byte arrays.\n * @param {ExtractionOptions} [options]\n *  Options for controlling how values are transformed when extracted\n *  from an Arrow binary representation.\n * @returns {Table} A Table instance.\n */\nexport function tableFromIPC(data, options) {\n  return createTable(decodeIPC(data), options);\n}\n\n/**\n * Create a table from parsed IPC data.\n * @param {ArrowData} data\n *  The IPC data, as returned by parseIPC.\n * @param {ExtractionOptions} [options]\n *  Options for controlling how values are transformed when extracted\n *  from am Arrow binary representation.\n * @returns {Table} A Table instance.\n */\nexport function createTable(data, options = {}) {\n  const { schema = { fields: [] }, dictionaries, records } = data;\n  const { version, fields } = schema;\n  const dictionaryMap = new Map;\n  const context = contextGenerator(options, version, dictionaryMap);\n\n  // build dictionary type map\n  const dictionaryTypes = new Map;\n  visitSchemaFields(schema, field => {\n    const type = field.type;\n    if (type.typeId === Type.Dictionary) {\n      dictionaryTypes.set(type.id, type.dictionary);\n    }\n  });\n\n  // decode dictionaries, build dictionary column map\n  const dicts = new Map;\n  for (const dict of dictionaries) {\n    const { id, data, isDelta, body } = dict;\n    const type = dictionaryTypes.get(id);\n    const batch = visit(type, context({ ...data, body }));\n    if (!dicts.has(id)) {\n      if (isDelta) {\n        throw new Error('Delta update can not be first dictionary batch.');\n      }\n      dicts.set(id, columnBuilder(type).add(batch));\n    } else {\n      const dict = dicts.get(id);\n      if (!isDelta) dict.clear();\n      dict.add(batch);\n    }\n  }\n  dicts.forEach((value, key) => dictionaryMap.set(key, value.done()));\n\n  // decode column fields\n  const cols = fields.map(f => columnBuilder(f.type));\n  for (const batch of records) {\n    const ctx = context(batch);\n    fields.forEach((f, i) => cols[i].add(visit(f.type, ctx)));\n  }\n\n  return new Table(schema, cols.map(c => c.done()), options.useProxy);\n}\n\n/**\n * Visit all fields within a schema.\n * @param {Schema} schema\n * @param {(field: Field) => void} visitor\n */\nfunction visitSchemaFields(schema, visitor) {\n  schema.fields.forEach(function visitField(field) {\n    visitor(field);\n    // @ts-ignore\n    field.type.dictionary?.children?.forEach(visitField);\n    // @ts-ignore\n    field.type.children?.forEach(visitField);\n  });\n}\n\n/**\n * Context object generator for field visitation and buffer definition.\n */\nfunction contextGenerator(options, version, dictionaryMap) {\n  const base = {\n    version,\n    options,\n    dictionary: id => dictionaryMap.get(id),\n  };\n\n  /**\n   * Return a context generator.\n   * @param {RecordBatch} batch\n   */\n  return batch => {\n    const { length, nodes, regions, compression, variadic, body } = batch;\n    let nodeIndex = -1;\n    let bufferIndex = -1;\n    let variadicIndex = -1;\n    return {\n      ...base,\n      length,\n      node: () => nodes[++nodeIndex],\n      buffer: (ArrayType) => {\n        const { bytes, length, offset } = maybeDecompress(body, regions[++bufferIndex], compression);\n        return ArrayType\n          ? new ArrayType(bytes.buffer, bytes.byteOffset + offset, length / ArrayType.BYTES_PER_ELEMENT)\n          : bytes.subarray(offset, offset + length)\n      },\n      variadic: () => variadic[++variadicIndex],\n      visit(children) { return children.map(f => visit(f.type, this)); }\n    };\n  };\n}\n\n/**\n * Prepare an arrow buffer for use, potentially decompressing it.\n * @param {Uint8Array} body\n * @param {{offset: number, length: number}} region\n * @param {BodyCompression} compression\n */\nfunction maybeDecompress(body, region, compression) {\n  if (!compression) {\n    return { bytes: body, ...region };\n  } else if (compression.method !== BodyCompressionMethod.BUFFER) {\n    throw new Error(`Unknown compression method (${compression.method})`);\n  } else {\n    const id = compression.codec;\n    const codec = getCompressionCodec(id);\n    if (!codec) throw new Error(missingCodec(id));\n    return decompressBuffer(body, region, codec);\n  }\n}\n\n/**\n * Visit a field, instantiating views of buffer regions.\n */\nfunction visit(type, ctx) {\n  const { typeId } = type;\n  const { options, node, buffer, variadic, version } = ctx;\n  const BatchType = batchType(type, options);\n\n  // extract the next { length, nullCount } field node - ALL fields have field nodes\n  const base = { ...node(), type };\n\n  if (typeId === Type.Null) {\n    // null fields have field nodes but no data buffers\n    return new BatchType({ ...base, nullCount: base.length });\n  }\n\n  switch (typeId) {\n    // validity and data value buffers\n    case Type.Bool:\n    case Type.Int:\n    case Type.Time:\n    case Type.Duration:\n    case Type.Float:\n    case Type.Decimal:\n    case Type.Date:\n    case Type.Timestamp:\n    case Type.Interval:\n    case Type.FixedSizeBinary:\n      return new BatchType({\n        ...base,\n        validity: buffer(),\n        values: buffer(type.values)\n      });\n\n    // validity, offset, and value buffers\n    case Type.Utf8:\n    case Type.LargeUtf8:\n    case Type.Binary:\n    case Type.LargeBinary:\n      return new BatchType({\n        ...base,\n        validity: buffer(),\n        offsets: buffer(type.offsets),\n        values: buffer()\n      });\n\n    // views with variadic buffers\n    case Type.BinaryView:\n    case Type.Utf8View:\n      return new BatchType({\n        ...base,\n        validity: buffer(),\n        values: buffer(), // views buffer\n        data: Array.from({ length: variadic() }, () => buffer()) // data buffers\n      });\n\n    // validity, offset, and list child\n    case Type.List:\n    case Type.LargeList:\n    case Type.Map:\n      return new BatchType({\n        ...base,\n        validity: buffer(),\n        offsets: buffer(type.offsets),\n        children: ctx.visit(type.children)\n      });\n\n    // validity, offset, size, and list child\n    case Type.ListView:\n    case Type.LargeListView:\n      return new BatchType({\n        ...base,\n        validity: buffer(),\n        offsets: buffer(type.offsets),\n        sizes: buffer(type.offsets),\n        children: ctx.visit(type.children)\n      });\n\n    // validity and children\n    case Type.FixedSizeList:\n    case Type.Struct:\n      return new BatchType({\n        ...base,\n        validity: buffer(),\n        children: ctx.visit(type.children)\n      });\n\n    // children only\n    case Type.RunEndEncoded:\n      return new BatchType({\n        ...base,\n        children: ctx.visit(type.children)\n      });\n\n    // dictionary\n    case Type.Dictionary: {\n      const { id, indices } = type;\n      return new BatchType({\n        ...base,\n        validity: buffer(),\n        values: buffer(indices.values),\n      }).setDictionary(ctx.dictionary(id));\n    }\n\n    // union\n    case Type.Union: {\n      if (version < Version.V5) {\n        buffer(); // skip unused null bitmap\n      }\n      return new BatchType({\n        ...base,\n        typeIds: buffer(int8Array),\n        offsets: type.mode === UnionMode.Sparse ? null : buffer(type.offsets),\n        children: ctx.visit(type.children)\n      });\n    }\n\n    // unsupported type\n    default:\n      throw new Error(invalidDataType(typeId));\n  }\n}\n","/**\n * @import { BodyCompression, RecordBatch } from '../types.js';\n * @import { Builder } from './builder.js';\n */\nimport { BodyCompressionMethod, CompressionType } from '../constants.js';\n\n/**\n * @param {Builder} builder\n * @param {RecordBatch} batch\n * @param {BodyCompression | null} [compression]\n * @returns {number}\n */\nexport function encodeRecordBatch(builder, batch, compression) {\n  const { nodes, regions, variadic } = batch;\n  const nodeVector = builder.addVector(nodes, 16, 8,\n    (builder, node) => {\n      builder.writeInt64(node.nullCount);\n      builder.writeInt64(node.length);\n      return builder.offset();\n    }\n  );\n  const regionVector = builder.addVector(regions, 16, 8,\n    (builder, region) => {\n      builder.writeInt64(region.length);\n      builder.writeInt64(region.offset);\n      return builder.offset();\n    }\n  );\n  const variadicVector = builder.addVector(variadic, 8, 8,\n    (builder, count) => builder.addInt64(count)\n  );\n  return builder.addObject(5, b => {\n    b.addInt64(0, nodes[0].length, 0);\n    b.addOffset(1, nodeVector, 0);\n    b.addOffset(2, regionVector, 0);\n    b.addOffset(3, encodeCompression(builder, compression), 0);\n    b.addOffset(4, variadicVector, 0);\n  });\n}\n\n/**\n * @param {Builder} builder\n * @param {BodyCompression | null} [compression]\n * @returns {number}\n */\nfunction encodeCompression(builder, compression) {\n  if (!compression) return 0;\n  const { codec, method } = compression;\n  return builder.addObject(2, b => {\n    b.addInt8(0, codec, CompressionType.LZ4_FRAME);\n    b.addInt8(1, method, BodyCompressionMethod.BUFFER);\n  });\n}\n","/**\n * @import { BodyCompression, DictionaryBatch } from '../types.js';\n * @import { Builder } from './builder.js';\n */\nimport { encodeRecordBatch } from './record-batch.js';\n\n/**\n * @param {Builder} builder\n * @param {DictionaryBatch} dictionaryBatch\n * @param {BodyCompression | null} compression\n * @returns {number}\n */\nexport function encodeDictionaryBatch(builder, dictionaryBatch, compression) {\n  const dataOffset = encodeRecordBatch(builder, dictionaryBatch.data, compression);\n  return builder.addObject(3, b => {\n    b.addInt64(0, dictionaryBatch.id, 0);\n    b.addOffset(1, dataOffset, 0);\n    b.addInt8(2, +dictionaryBatch.isDelta, 0);\n  });\n}\n","/**\n * @import { Builder } from './builder.js';\n */\n\n/**\n * @param {Builder} builder\n * @param {Map<string, string>} metadata\n * @returns {number}\n */\nexport function encodeMetadata(builder, metadata) {\n  return metadata?.size > 0\n     ? builder.addOffsetVector(Array.from(metadata, ([k, v]) => {\n        const key = builder.addString(`${k}`);\n        const val = builder.addString(`${v}`);\n        return builder.addObject(2, b => {\n          b.addOffset(0, key, 0);\n          b.addOffset(1, val, 0);\n        });\n      }))\n    : 0;\n}\n","/**\n * @import { DataType } from '../types.js';\n * @import { Builder } from './builder.js';\n */\nimport { DateUnit, IntervalUnit, Precision, TimeUnit, Type, UnionMode } from '../constants.js';\nimport { invalidDataType } from '../data-types.js';\nimport { checkOneOf } from '../util/objects.js';\n\n/**\n * Encode a data type into a flatbuffer.\n * @param {Builder} builder\n * @param {DataType} type\n * @returns {number} The offset at which the data type is written.\n */\nexport function encodeDataType(builder, type) {\n  const typeId = checkOneOf(type.typeId, Type, invalidDataType);\n\n  switch (typeId) {\n    case Type.Dictionary:\n      return encodeDictionary(builder, type);\n    case Type.Int:\n      return encodeInt(builder, type);\n    case Type.Float:\n      return encodeFloat(builder, type);\n    case Type.Decimal:\n      return encodeDecimal(builder, type);\n    case Type.Date:\n      return encodeDate(builder, type);\n    case Type.Time:\n      return encodeTime(builder, type);\n    case Type.Timestamp:\n      return encodeTimestamp(builder, type);\n    case Type.Interval:\n      return encodeInterval(builder, type);\n    case Type.Duration:\n      return encodeDuration(builder, type);\n    case Type.FixedSizeBinary:\n    case Type.FixedSizeList:\n      return encodeFixedSize(builder, type);\n    case Type.Map:\n      return encodeMap(builder, type);\n    case Type.Union:\n      return encodeUnion(builder, type);\n  }\n  // case Type.Null:\n  // case Type.Binary:\n  // case Type.LargeBinary:\n  // case Type.BinaryView:\n  // case Type.Bool:\n  // case Type.Utf8:\n  // case Type.Utf8View:\n  // case Type.LargeUtf8:\n  // case Type.List:\n  // case Type.ListView:\n  // case Type.LargeList:\n  // case Type.LargeListView:\n  // case Type.RunEndEncoded:\n  // case Type.Struct:\n  return builder.addObject(0);\n}\n\nfunction encodeDate(builder, type) {\n  return builder.addObject(1, b => {\n    b.addInt16(0, type.unit, DateUnit.MILLISECOND);\n  });\n}\n\nfunction encodeDecimal(builder, type) {\n  return builder.addObject(3, b => {\n    b.addInt32(0, type.precision, 0);\n    b.addInt32(1, type.scale, 0);\n    b.addInt32(2, type.bitWidth, 128);\n  });\n}\n\nfunction encodeDuration(builder, type) {\n  return builder.addObject(1, b => {\n    b.addInt16(0, type.unit, TimeUnit.MILLISECOND);\n  });\n}\n\nfunction encodeFixedSize(builder, type) {\n  return builder.addObject(1, b => {\n    b.addInt32(0, type.stride, 0);\n  });\n}\n\nfunction encodeFloat(builder, type) {\n  return builder.addObject(1, b => {\n    b.addInt16(0, type.precision, Precision.HALF);\n  });\n}\n\nfunction encodeInt(builder, type) {\n  return builder.addObject(2, b => {\n    b.addInt32(0, type.bitWidth, 0);\n    b.addInt8(1, +type.signed, 0);\n  });\n}\n\nfunction encodeInterval(builder, type) {\n  return builder.addObject(1, b => {\n    b.addInt16(0, type.unit, IntervalUnit.YEAR_MONTH);\n  });\n}\n\nfunction encodeMap(builder, type) {\n  return builder.addObject(1, b => {\n    b.addInt8(0, +type.keysSorted, 0);\n  });\n}\n\nfunction encodeTime(builder, type) {\n  return builder.addObject(2, b => {\n    b.addInt16(0, type.unit, TimeUnit.MILLISECOND);\n    b.addInt32(1, type.bitWidth, 32);\n  });\n}\n\nfunction encodeTimestamp(builder, type) {\n  const timezoneOffset = builder.addString(type.timezone);\n  return builder.addObject(2, b => {\n    b.addInt16(0, type.unit, TimeUnit.SECOND);\n    b.addOffset(1, timezoneOffset, 0);\n  });\n}\n\nfunction encodeUnion(builder, type) {\n  const typeIdsOffset = builder.addVector(\n    type.typeIds, 4, 4,\n    (builder, value) => builder.addInt32(value)\n  );\n  return builder.addObject(2, b => {\n    b.addInt16(0, type.mode, UnionMode.Sparse);\n    b.addOffset(1, typeIdsOffset, 0);\n  });\n}\n\nfunction encodeDictionary(builder, type) {\n  // The Arrow spec uses signed 32-bit integers as the default index type.\n  // However, multiple 3rd party tools fail on a null (default) index type,\n  // so we always encode the index data type explicitly here.\n  return builder.addObject(4, b => {\n    b.addInt64(0, type.id, 0);\n    b.addOffset(1, encodeDataType(builder, type.indices), 0);\n    b.addInt8(2, +type.ordered, 0);\n    // NOT SUPPORTED: 3, dictionaryKind (defaults to dense array)\n  });\n}\n","/**\n * @import { DictionaryType, Field, Schema } from '../types.js';\n * @import { Builder } from './builder.js';\n */\nimport { Type } from '../constants.js';\nimport { encodeDataType } from './data-type.js';\nimport { encodeMetadata } from './metadata.js';\n\nconst isLittleEndian = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;\n\n/**\n * @param {Builder} builder\n * @param {Schema} schema\n * @returns {number}\n */\nexport function encodeSchema(builder, schema) {\n  const { fields, metadata } = schema;\n  const fieldOffsets = fields.map(f => encodeField(builder, f));\n  const fieldsVectorOffset = builder.addOffsetVector(fieldOffsets);\n  const metadataOffset = encodeMetadata(builder, metadata);\n  return builder.addObject(4, b => {\n    b.addInt16(0, +(!isLittleEndian), 0);\n    b.addOffset(1, fieldsVectorOffset, 0);\n    b.addOffset(2, metadataOffset, 0);\n    // NOT SUPPORTED: 3, features\n  });\n}\n\n/**\n * @param {Builder} builder\n * @param {Field} field\n * @returns {number}\n */\nfunction encodeField(builder, field) {\n  const { name, nullable, type, metadata } = field;\n  let { typeId } = type;\n\n  // encode field data type\n  let typeOffset = 0;\n  let dictionaryOffset = 0;\n  if (typeId !== Type.Dictionary) {\n    typeOffset = encodeDataType(builder, type);\n  } else {\n    const dict = /** @type {DictionaryType} */ (type).dictionary;\n    typeId = dict.typeId;\n    dictionaryOffset = encodeDataType(builder, type);\n    typeOffset = encodeDataType(builder, dict);\n  }\n\n  // encode children, metadata, name, and field object\n  // @ts-ignore\n  const childOffsets = (type.children || []).map(f => encodeField(builder, f));\n  const childrenVectorOffset = builder.addOffsetVector(childOffsets);\n  const metadataOffset = encodeMetadata(builder, metadata);\n  const nameOffset = builder.addString(name);\n  return builder.addObject(7, b => {\n    b.addOffset(0, nameOffset, 0);\n    b.addInt8(1, +nullable, +false);\n    b.addInt8(2, typeId, Type.NONE);\n    b.addOffset(3, typeOffset, 0);\n    b.addOffset(4, dictionaryOffset, 0);\n    b.addOffset(5, childrenVectorOffset, 0);\n    b.addOffset(6, metadataOffset, 0);\n  });\n}\n","/**\n * @import { Block, Schema } from '../types.js';\n * @import { Builder } from './builder.js';\n */\nimport { MAGIC, Version } from '../constants.js';\nimport { encodeMetadata } from './metadata.js';\nimport { encodeSchema } from './schema.js';\n\n/**\n * Write a file footer.\n * @param {Builder} builder The binary builder.\n * @param {Schema} schema The table schema.\n * @param {Block[]} dictBlocks Dictionary batch file blocks.\n * @param {Block[]} recordBlocks Record batch file blocks.\n * @param {Map<string,string> | null} metadata File-level metadata.\n */\nexport function writeFooter(builder, schema, dictBlocks, recordBlocks, metadata) {\n  // encode footer flatbuffer\n  const metadataOffset = encodeMetadata(builder, metadata);\n  const recsOffset = builder.addVector(recordBlocks, 24, 8, encodeBlock);\n  const dictsOffset = builder.addVector(dictBlocks, 24, 8, encodeBlock);\n  const schemaOffset = encodeSchema(builder, schema);\n  builder.finish(\n    builder.addObject(5, b => {\n      b.addInt16(0, Version.V5, Version.V1);\n      b.addOffset(1, schemaOffset, 0);\n      b.addOffset(2, dictsOffset, 0);\n      b.addOffset(3, recsOffset, 0);\n      b.addOffset(4, metadataOffset, 0);\n    })\n  );\n  const size = builder.offset();\n\n  // add eos with continuation indicator\n  builder.addInt32(0);\n  builder.addInt32(-1);\n\n  // write builder contents\n  builder.flush();\n\n  // write file tail\n  builder.sink.write(new Uint8Array(Int32Array.of(size).buffer));\n  builder.sink.write(MAGIC);\n}\n\n/**\n * Encode a file pointer block.\n * @param {Builder} builder\n * @param {Block} block\n * @returns {number} the current block offset\n */\nfunction encodeBlock(builder, { offset, metadataLength, bodyLength }) {\n  builder.writeInt64(bodyLength);\n  builder.writeInt32(0);\n  builder.writeInt32(metadataLength);\n  builder.writeInt64(offset);\n  return builder.offset();\n}\n","/**\n * @import { Block, MessageHeader_ } from '../types.js';\n * @import { Builder } from './builder.js';\n */\nimport { MessageHeader, Version } from '../constants.js';\n\n/**\n * Write an IPC message to the builder sink.\n * @param {Builder} builder\n * @param {MessageHeader_} headerType\n * @param {number} headerOffset\n * @param {number} bodyLength\n * @param {Block[]} [blocks]\n */\nexport function writeMessage(builder, headerType, headerOffset, bodyLength, blocks) {\n  builder.finish(\n    builder.addObject(5, b => {\n      b.addInt16(0, Version.V5, Version.V1);\n      b.addInt8(1, headerType, MessageHeader.NONE);\n      b.addOffset(2, headerOffset, 0);\n      b.addInt64(3, bodyLength, 0);\n      // NOT SUPPORTED: 4, message-level metadata\n    })\n  );\n\n  const prefixSize = 8; // continuation indicator + message size\n  const messageSize = builder.offset();\n  const alignedSize = (messageSize + prefixSize + 7) & ~7;\n\n  // track blocks for file footer\n  blocks?.push({\n    offset: builder.outputBytes,\n    metadataLength: alignedSize,\n    bodyLength\n  });\n\n  // write size prefix (including padding)\n  builder.addInt32(alignedSize - prefixSize);\n\n  // write the stream continuation indicator\n  builder.addInt32(-1);\n\n  // flush the builder content\n  builder.flush();\n\n  // add alignment padding as needed\n  builder.addPadding(alignedSize - messageSize - prefixSize);\n}\n","export class Sink {\n  /**\n   * Write bytes to this sink.\n   * @param {Uint8Array} bytes The byte buffer to write.\n   */\n  write(bytes) { // eslint-disable-line no-unused-vars\n  }\n\n  /**\n   * Write padding bytes (zeroes) to this sink.\n   * @param {number} byteCount The number of padding bytes.\n   */\n  pad(byteCount) {\n    this.write(new Uint8Array(byteCount));\n  }\n\n  /**\n   * @returns {Uint8Array | null}\n   */\n  finish() {\n    return null;\n  }\n}\n\nexport class MemorySink extends Sink {\n  /**\n   * A sink that collects bytes in memory.\n   */\n  constructor() {\n    super();\n    this.buffers = [];\n  }\n\n  /**\n   * Write bytes\n   * @param {Uint8Array} bytes\n   */\n  write(bytes) {\n    this.buffers.push(bytes);\n  }\n\n  /**\n   * @returns {Uint8Array}\n   */\n  finish() {\n    const bufs = this.buffers;\n    const size = bufs.reduce((sum, b) => sum + b.byteLength, 0);\n    const buf = new Uint8Array(size);\n    for (let i = 0, off = 0; i < bufs.length; ++i) {\n      buf.set(bufs[i], off);\n      off += bufs[i].byteLength;\n    }\n    return buf;\n  }\n}\n","/**\n * @import { Sink } from './sink.js';\n * @import { CompressionType_ } from '../types.js';\n */\nimport { BodyCompressionMethod, EOS, MAGIC, MessageHeader } from '../constants.js';\nimport { Builder } from './builder.js';\nimport { encodeDictionaryBatch } from './dictionary-batch.js';\nimport { writeFooter } from './footer.js';\nimport { encodeRecordBatch } from './record-batch.js';\nimport { encodeSchema } from './schema.js';\nimport { writeMessage } from './message.js';\nimport { MemorySink } from './sink.js';\n\nconst STREAM = 'stream';\nconst FILE = 'file';\n\n/**\n * Encode assembled data into Arrow IPC binary format.\n * @param {any} data Assembled table data.\n * @param {object} options Encoding options.\n * @param {Sink} [options.sink] IPC byte consumer.\n * @param {'stream' | 'file'} [options.format] Arrow stream or file format.\n * @param {CompressionType_} [options.codec] Compression codec to apply.\n * @returns {Sink} The sink that was passed in.\n */\nexport function encodeIPC(data, { sink, format = STREAM, codec } = {}) {\n  if (format !== STREAM && format !== FILE) {\n    throw new Error(`Unrecognized Arrow IPC format: ${format}`);\n  }\n  const { schema, dictionaries = [], records = [], metadata } = data;\n  const builder = new Builder(sink || new MemorySink());\n  const file = format === FILE;\n  const dictBlocks = [];\n  const recordBlocks = [];\n  const compression = codec != null\n    ? { codec, method: BodyCompressionMethod.BUFFER }\n    : null;\n\n  if (file) {\n    builder.addBuffer(MAGIC);\n  }\n\n  // both stream and file start with the schema\n  if (schema) {\n    writeMessage(\n      builder,\n      MessageHeader.Schema,\n      encodeSchema(builder, schema),\n      0\n    );\n  }\n\n  // write dictionary messages\n  for (const dict of dictionaries) {\n    const { data } = dict;\n    writeMessage(\n      builder,\n      MessageHeader.DictionaryBatch,\n      encodeDictionaryBatch(builder, dict, compression),\n      data.byteLength,\n      dictBlocks\n    );\n    writeBuffers(builder, data.buffers);\n  }\n\n  // write record batch messages\n  for (const batch of records) {\n    writeMessage(\n      builder,\n      MessageHeader.RecordBatch,\n      encodeRecordBatch(builder, batch, compression),\n      batch.byteLength,\n      recordBlocks\n    );\n    writeBuffers(builder, batch.buffers);\n  }\n\n  // both stream and file include end-of-stream message\n  builder.addBuffer(EOS);\n\n  if (file) {\n    writeFooter(builder, schema, dictBlocks, recordBlocks, metadata);\n  }\n\n  return builder.sink;\n}\n\n/**\n * Write byte buffers to the builder sink.\n * Buffers are aligned to 64 bits (8 bytes) as needed.\n * @param {Builder} builder\n * @param {Uint8Array[]} buffers\n */\nfunction writeBuffers(builder, buffers) {\n  for (let i = 0; i < buffers.length; ++i) {\n    builder.addBuffer(buffers[i]); // handles alignment for us\n  }\n}\n","/**\n * @import { Batch, DictionaryBatch } from '../batch.js';\n * @import { Column } from '../column.js';\n * @import { Table } from '../table.js';\n * @import { Codec, CompressionType_, DataType, RecordBatch, Schema, TypedArray } from '../types.js';\n * @import { Sink } from './sink.js';\n */\nimport { compressBuffer, getCompressionCodec, missingCodec } from '../compression.js';\nimport { Type, UnionMode } from '../constants.js';\nimport { invalidDataType } from '../data-types.js';\nimport { encodeIPC } from './encode-ipc.js';\n\n/**\n * Encode an Arrow table into Arrow IPC binary format.\n * @param {Table} table The Arrow table to encode.\n * @param {object} options Encoding options.\n * @param {Sink} [options.sink] IPC byte consumer.\n * @param {'stream' | 'file'} [options.format] Arrow stream or file format.\n * @param {CompressionType_ | null} [options.codec] Compression codec to apply.\n * @returns {Uint8Array | null} The generated bytes (for an in-memory sink)\n *  or null (if using a sink that writes bytes elsewhere).\n */\nexport function tableToIPC(table, options) {\n  // accept a format string option for Arrow-JS compatibility\n  if (typeof options === 'string') {\n    options = { format: options };\n  }\n\n  // resolve compression codec\n  const id = options?.codec;\n  const codec = getCompressionCodec(id);\n  if (id != null && !codec) throw new Error(missingCodec(id));\n\n  const columns = table.children;\n  checkBatchLengths(columns);\n\n  const { dictionaries, idMap } = assembleDictionaryBatches(columns, codec);\n  const records = assembleRecordBatches(columns, codec);\n  const schema = assembleSchema(table.schema, idMap);\n  const data = { schema, dictionaries, records };\n  return encodeIPC(data, { ...options, codec: id }).finish();\n}\n\nfunction checkBatchLengths(columns) {\n  const n = columns[0]?.data.map(d => d.length);\n  columns.forEach(({ data }) => {\n    if (data.length !== n.length || data.some((b, i) => b.length !== n[i])) {\n      throw new Error('Columns have inconsistent batch sizes.');\n    }\n  });\n}\n\n/**\n * Create a new assembly context.\n * @param {Codec} [codec] Optional buffer compression codec.\n */\nfunction assembleContext(codec) {\n  let byteLength = 0;\n  const nodes = [];\n  const regions = [];\n  const buffers = [];\n  const variadic = [];\n  return {\n    /**\n     * @param {number} length\n     * @param {number} nullCount\n     */\n    node(length, nullCount) {\n      nodes.push({ length, nullCount });\n    },\n    /**\n     * @param {TypedArray} b\n     */\n    buffer(b) {\n      const bytes = new Uint8Array(b.buffer, b.byteOffset, b.byteLength);\n      const buf = codec ? compressBuffer(bytes, codec) : bytes;\n      const length = buf.byteLength;\n      regions.push({ offset: byteLength, length });\n      buffers.push(buf);\n      byteLength += ((length + 7) & ~7); // align to padding\n    },\n    /**\n     * @param {number} length\n     */\n    variadic(length) {\n      variadic.push(length);\n    },\n    /**\n     * @param {DataType} type\n     * @param {Batch} batch\n     */\n    children(type, batch) {\n      // @ts-ignore\n      type.children.forEach((field, index) => {\n        visit(field.type, batch.children[index], this);\n      });\n    },\n    /**\n     * @returns {RecordBatch}\n     */\n    done() {\n      return { byteLength, nodes, regions, variadic, buffers };\n    }\n  };\n}\n\n/**\n * Assemble dictionary batches and their unique ids.\n * @param {Column[]} columns The table columns.\n * @param {Codec} [codec] Optional buffer compression codec.\n * @returns {{\n *    dictionaries: DictionaryBatch[],\n *    idMap: Map<DataType, number>\n *  }}\n *  The assembled dictionary batches and a map from dictionary column\n *  instances to dictionary ids.\n */\nfunction assembleDictionaryBatches(columns, codec) {\n  const dictionaries = [];\n  const dictMap = new Map;\n  const idMap = new Map;\n  let id = -1;\n\n  // track dictionaries, key by dictionary column, assign ids\n  const visitor = dictionaryColumn => {\n    if (!dictMap.has(dictionaryColumn)) {\n      dictMap.set(dictionaryColumn, ++id);\n      for (let i = 0; i < dictionaryColumn.data.length; ++i) {\n        dictionaries.push({\n          id,\n          isDelta: i > 0,\n          data: assembleRecordBatch([dictionaryColumn], i, codec)\n        });\n      }\n      idMap.set(dictionaryColumn.type, id);\n    } else {\n      idMap.set(dictionaryColumn.type, dictMap.get(dictionaryColumn));\n    }\n  };\n\n  // recurse through column batches to find dictionaries\n  // it is sufficient to visit the first batch only,\n  // as all batches have the same dictionary column\n  columns.forEach(col => visitDictionaries(col.data[0], visitor));\n\n  return { dictionaries, idMap };\n}\n\n/**\n * Traverse column batches to visit dictionary columns.\n * @param {Batch} batch\n * @param {(column: Column) => void} visitor\n */\nfunction visitDictionaries(batch, visitor) {\n  if (batch?.type.typeId === Type.Dictionary) {\n    // @ts-ignore - batch has type DictionaryBatch\n    const dictionary = batch.dictionary;\n    visitor(dictionary);\n    visitDictionaries(dictionary.data[0], visitor);\n  }\n  batch?.children?.forEach(child => visitDictionaries(child, visitor));\n}\n\n/**\n * Assemble a schema with resolved dictionary ids.\n * @param {Schema} schema The schema.\n * @param {Map<DataType, number>} idMap A map\n *  from dictionary value types to dictionary ids.\n * @returns {Schema} A new schema with resolved\n *  dictionary ids. If there are no dictionaries, the input schema is\n *  returned unchanged.\n */\nfunction assembleSchema(schema, idMap) {\n  // early exit if no dictionaries\n  if (!idMap.size) return schema;\n\n  const visit = type => {\n    if (type.typeId === Type.Dictionary) {\n      type.id = idMap.get(type.dictionary); // lookup and set id\n      visitDictType(type);\n    }\n    if (type.children) {\n      (type.children = type.children.slice()).forEach(visitFields);\n    }\n  };\n\n  // visit a field in a field array\n  const visitFields = (field, index, array) => {\n    const type = { ...field.type };\n    array[index] = { ...field, type };\n    visit(type);\n  };\n\n  // visit a dictionary values type\n  const visitDictType = (parentType) => {\n    const type = { ...parentType.dictionary };\n    parentType.dictionary = type;\n    visit(type);\n  };\n\n  schema = { ...schema, fields: schema.fields.slice() };\n  schema.fields.forEach(visitFields);\n  return schema;\n}\n\n/**\n * Assemble record batches with marshalled buffers.\n * @param {Column[]} columns The table columns.\n * @param {Codec} [codec] Optional buffer compression codec.\n * @returns {RecordBatch[]} The assembled record batches.\n */\nfunction assembleRecordBatches(columns, codec) {\n  return (columns[0]?.data || [])\n    .map((_, index) => assembleRecordBatch(columns, index, codec));\n}\n\n/**\n * Assemble a record batch with marshalled buffers.\n * @param {Column[]} columns The table columns.\n * @param {number} batchIndex The batch index.\n * @param {Codec} [codec] Optional buffer compression codec.\n * @returns {RecordBatch} The assembled record batch.\n */\nfunction assembleRecordBatch(columns, batchIndex = 0, codec) {\n  const ctx = assembleContext(codec);\n  columns.forEach(column => {\n    visit(column.type, column.data[batchIndex], ctx);\n  });\n  return ctx.done();\n}\n\n/**\n * Visit a column batch, assembling buffer data.\n * @param {DataType} type The data type.\n * @param {Batch} batch The column batch.\n * @param {ReturnType<assembleContext>} ctx The assembly context.\n */\nfunction visit(type, batch, ctx) {\n  const { typeId } = type;\n\n  // record field node info - ALL fields need field nodes, including nulls\n  ctx.node(batch.length, batch.nullCount);\n\n  // null fields have field nodes but no data buffers\n  if (typeId === Type.Null) return;\n\n  switch (typeId) {\n    // validity and value buffers\n    // backing dictionaries handled elsewhere\n    case Type.Bool:\n    case Type.Int:\n    case Type.Time:\n    case Type.Duration:\n    case Type.Float:\n    case Type.Date:\n    case Type.Timestamp:\n    case Type.Decimal:\n    case Type.Interval:\n    case Type.FixedSizeBinary:\n    case Type.Dictionary: // dict key values\n      ctx.buffer(batch.validity);\n      ctx.buffer(batch.values);\n      return;\n\n    // validity, offset, and value buffers\n    case Type.Utf8:\n    case Type.LargeUtf8:\n    case Type.Binary:\n    case Type.LargeBinary:\n      ctx.buffer(batch.validity);\n      ctx.buffer(batch.offsets);\n      ctx.buffer(batch.values);\n      return;\n\n    // views with variadic buffers\n    case Type.BinaryView:\n    case Type.Utf8View:\n      ctx.buffer(batch.validity);\n      ctx.buffer(batch.values);\n      // @ts-ignore\n      ctx.variadic(batch.data.length);\n      // @ts-ignore\n      batch.data.forEach(b => ctx.buffer(b));\n      return;\n\n    // validity, offset, and list child\n    case Type.List:\n    case Type.LargeList:\n    case Type.Map:\n      ctx.buffer(batch.validity);\n      ctx.buffer(batch.offsets);\n      ctx.children(type, batch);\n      return;\n\n    // validity, offset, size, and list child\n    case Type.ListView:\n    case Type.LargeListView:\n      ctx.buffer(batch.validity);\n      ctx.buffer(batch.offsets);\n      ctx.buffer(batch.sizes);\n      ctx.children(type, batch);\n      return;\n\n    // validity and children\n    case Type.FixedSizeList:\n    case Type.Struct:\n      ctx.buffer(batch.validity);\n      ctx.children(type, batch);\n      return;\n\n    // children only\n    case Type.RunEndEncoded:\n      ctx.children(type, batch);\n      return;\n\n    // union\n    case Type.Union: {\n      // @ts-ignore\n      ctx.buffer(batch.typeIds);\n      if (type.mode === UnionMode.Dense) {\n        ctx.buffer(batch.offsets);\n      }\n      ctx.children(type, batch);\n      return;\n    }\n\n    // unsupported type\n    default:\n      throw new Error(invalidDataType(typeId));\n  }\n}\n","/**\n * @import { TypedArray, TypedArrayConstructor } from '../types.js'\n */\nimport { align, grow, uint8Array } from '../util/arrays.js';\n\n/**\n * Create a new resizable buffer instance.\n * @param {TypedArrayConstructor} [arrayType]\n *  The array type.\n * @returns {Buffer} The buffer.\n */\nexport function buffer(arrayType) {\n  return new Buffer(arrayType);\n}\n\n/**\n * Resizable byte buffer.\n */\nexport class Buffer {\n  /**\n   * Create a new resizable buffer instance.\n   * @param {TypedArrayConstructor} arrayType\n   */\n  constructor(arrayType = uint8Array) {\n    this.buf = new arrayType(512);\n  }\n  /**\n   * Return the underlying data as a 64-bit aligned array of minimum size.\n   * @param {number} size The desired minimum array size.\n   * @returns {TypedArray} The 64-bit aligned array.\n   */\n  array(size) {\n    return align(this.buf, size);\n  }\n  /**\n   * Prepare for writes to the given index, resizing as necessary.\n   * @param {number} index The array index to prepare to write to.\n   */\n  prep(index) {\n    if (index >= this.buf.length) {\n      this.buf = grow(this.buf, index);\n    }\n  }\n  /**\n   * Return the value at the given index.\n   * @param {number} index The array index.\n   */\n  get(index) {\n    return this.buf[index];\n  }\n  /**\n   * Set a value at the given index.\n   * @param {number | bigint} value The value to set.\n   * @param {number} index The index to write to.\n   */\n  set(value, index) {\n    this.prep(index);\n    this.buf[index] = value;\n  }\n  /**\n   * Write a byte array at the given index. The method should be called\n   * only when the underlying buffer is of type Uint8Array.\n   * @param {Uint8Array} bytes The byte array.\n   * @param {number} index The starting index to write to.\n   */\n  write(bytes, index) {\n    this.prep(index + bytes.length);\n    /** @type {Uint8Array} */ (this.buf).set(bytes, index);\n  }\n}\n\n/**\n * Create a new resizable bitmap instance.\n * @returns {Bitmap} The bitmap buffer.\n */\nexport function bitmap() {\n  return new Bitmap();\n}\n\n/**\n * Resizable bitmap buffer.\n */\nexport class Bitmap extends Buffer {\n  /**\n   * Set a bit to true at the given bitmap index.\n   * @param {number} index The index to write to.\n   */\n  set(index) {\n    const i = index >> 3;\n    this.prep(i);\n    /** @type {Uint8Array} */ (this.buf)[i] |= (1 << (index % 8));\n  }\n}\n","/**\n * @import { Batch } from '../../batch.js'\n */\n\n/**\n * Abstract class for building a column data batch.\n */\nexport class BatchBuilder {\n  constructor(type, ctx) {\n    this.type = type;\n    this.ctx = ctx;\n    this.batchClass = ctx.batchType(type);\n  }\n\n  /**\n   * Initialize the builder state.\n   * @returns {this} This builder.\n   */\n  init() {\n    this.index = -1;\n    return this;\n  }\n\n  /**\n   * Write a value to the builder.\n   * @param {*} value\n   * @param {number} index\n   * @returns {boolean | void}\n   */\n  set(value, index) {\n    this.index = index;\n    return false;\n  }\n\n  /**\n   * Returns a batch constructor options object.\n   * Used internally to marshal batch data.\n   * @returns {Record<string, any>}\n   */\n  done() {\n    return null;\n  }\n\n  /**\n   * Returns a completed batch and reinitializes the builder state.\n   * @returns {Batch}\n   */\n  batch() {\n    const b = new this.batchClass(this.done());\n    this.init();\n    return b;\n  }\n}\n","import { uint8Array } from '../../util/arrays.js';\nimport { bitmap } from '../buffer.js';\nimport { BatchBuilder } from './batch.js';\n\n/**\n * Builder for validity bitmaps within batches.\n */\nexport class ValidityBuilder extends BatchBuilder {\n  constructor(type, ctx) {\n    super(type, ctx);\n  }\n\n  init() {\n    this.nullCount = 0;\n    this.validity = bitmap();\n    return super.init();\n  }\n\n  /**\n   * @param {*} value\n   * @param {number} index\n   * @returns {boolean | void}\n   */\n  set(value, index) {\n    this.index = index;\n    const isValid = value != null;\n    if (isValid) {\n      this.validity.set(index);\n    } else {\n      this.nullCount++;\n    }\n    return isValid;\n  }\n\n  done() {\n    const { index, nullCount, type, validity } = this;\n    return {\n      length: index + 1,\n      nullCount,\n      type,\n      validity: nullCount\n        ? validity.array((index >> 3) + 1)\n        : new uint8Array(0)\n    };\n  }\n}\n","/**\n * @import { builderContext } from '../builder.js'\n * @import { DictionaryType, ExtractionOptions } from '../../types.js'\n */\nimport { Column } from '../../column.js';\nimport { keyString } from '../../util/strings.js';\nimport { batchType } from '../../batch-type.js';\nimport { buffer } from '../buffer.js';\nimport { ValidityBuilder } from './validity.js';\n\n/**\n * Create a context object for managing dictionary builders.\n */\nexport function dictionaryContext() {\n  const idMap = new Map;\n  const dicts = new Set;\n  return {\n    /**\n     * Get a dictionary values builder for the given dictionary type.\n     * @param {DictionaryType} type\n     *  The dictionary type.\n     * @param {*} ctx The builder context.\n     * @returns {ReturnType<dictionaryValues>}\n     */\n    get(type, ctx) {\n      // if a dictionary has a non-negative id, assume it was set\n      // intentionally and track it for potential reuse across columns\n      // otherwise the dictionary is used for a single column only\n      const id = type.id;\n      if (id >= 0 && idMap.has(id)) {\n        return idMap.get(id);\n      } else {\n        const dict = dictionaryValues(type, ctx);\n        if (id >= 0) idMap.set(id, dict);\n        dicts.add(dict);\n        return dict;\n      }\n    },\n    /**\n     * Finish building dictionary values columns and assign them to\n     * their corresponding dictionary batches.\n     * @param {ExtractionOptions} options\n     */\n    finish(options) {\n      dicts.forEach(dict => dict.finish(options));\n    }\n  };\n}\n\n/**\n * Builder helper for creating dictionary values.\n * @param {DictionaryType} type\n *  The dictionary data type.\n * @param {ReturnType<builderContext>} ctx\n *  The builder context.\n */\nexport function dictionaryValues(type, ctx) {\n  const keys = Object.create(null);\n  const values = ctx.builder(type.dictionary);\n  const batches = [];\n\n  values.init();\n  let index = -1;\n\n  return {\n    type,\n    values,\n\n    add(batch) {\n      batches.push(batch);\n      return batch;\n    },\n\n    key(value) {\n      const v = keyString(value);\n      let k = keys[v];\n      if (k === undefined) {\n        keys[v] = k = ++index;\n        values.set(value, k);\n      }\n      return k;\n    },\n\n    finish(options) {\n      const valueType = type.dictionary;\n      const batch = new (batchType(valueType, options))(values.done());\n      const dictionary = new Column([batch]);\n      batches.forEach(batch => batch.setDictionary(dictionary));\n    }\n  };\n}\n\n/**\n * Builder for dictionary-typed data batches.\n */\nexport class DictionaryBuilder extends ValidityBuilder {\n  constructor(type, ctx) {\n    super(type, ctx);\n    this.dict = ctx.dictionary(type);\n  }\n\n  init() {\n    this.values = buffer(this.type.indices.values);\n    return super.init();\n  }\n\n  set(value, index) {\n    if (super.set(value, index)) {\n      this.values.set(this.dict.key(value), index);\n    }\n  }\n\n  done() {\n    return {\n      ...super.done(),\n      values: this.values.array(this.index + 1)\n    };\n  }\n\n  batch() {\n    // register batch with dictionary\n    // batch will be updated when the dictionary is finished\n    return this.dict.add(super.batch());\n  }\n}\n","/**\n * @import { DataType, IntType, UnionType } from '../types.js'\n */\nimport { bool, dateDay, dictionary, field, fixedSizeList, float64, int16, int32, int64, int8, list, nullType, struct, timestamp, utf8 } from '../data-types.js';\nimport { isArray } from '../util/arrays.js';\n\n/**\n * Infer the data type for a given input array.\n * @param {(visitor: (value: any) => void) => void} visit\n *  A function that applies a callback to successive data values.\n * @returns {DataType} The data type.\n */\nexport function inferType(visit) {\n  const profile = profiler();\n  visit(value => profile.add(value));\n  return profile.type();\n}\n\nfunction profiler() {\n  let length = 0;\n  let nullCount = 0;\n  let boolCount = 0;\n  let numberCount = 0;\n  let intCount = 0;\n  let bigintCount = 0;\n  let dateCount = 0;\n  let dayCount = 0;\n  let stringCount = 0;\n  let arrayCount = 0;\n  let structCount = 0;\n  let min = Infinity;\n  let max = -Infinity;\n  let minLength = Infinity;\n  let maxLength = -Infinity;\n  let minBigInt;\n  let maxBigInt;\n  let arrayProfile;\n  let structProfiles = {};\n\n  return {\n    add(value) {\n      length++;\n      if (value == null) {\n        nullCount++;\n        return;\n      }\n      switch (typeof value) {\n        case 'string':\n          stringCount++;\n          break;\n        case 'number':\n          numberCount++;\n          if (value < min) min = value;\n          if (value > max) max = value;\n          if (Number.isInteger(value)) intCount++;\n          break;\n        case 'bigint':\n          bigintCount++;\n          if (minBigInt === undefined) {\n            minBigInt = maxBigInt = value;\n          } else {\n            if (value < minBigInt) minBigInt = value;\n            if (value > maxBigInt) maxBigInt = value;\n          }\n          break;\n        case 'boolean':\n          boolCount++;\n          break;\n        case 'object':\n          if (value instanceof Date) {\n            dateCount++;\n            // 1 day = 1000ms * 60s * 60min * 24hr = 86400000\n            if ((+value % 864e5) === 0) dayCount++;\n          } else if (isArray(value)) {\n            arrayCount++;\n            const len = value.length;\n            if (len < minLength) minLength = len;\n            if (len > maxLength) maxLength = len;\n            arrayProfile ??= profiler();\n            value.forEach(arrayProfile.add);\n          } else {\n            structCount++;\n            for (const key in value) {\n              const fieldProfiler = structProfiles[key]\n                ?? (structProfiles[key] = profiler());\n              fieldProfiler.add(value[key]);\n            }\n          }\n      }\n    },\n    type() {\n      const valid = length - nullCount;\n      return valid === 0 ? nullType()\n        : intCount === valid ? intType(min, max)\n        : numberCount === valid ? float64()\n        : bigintCount === valid ? bigintType(minBigInt, maxBigInt)\n        : boolCount === valid ? bool()\n        : dayCount === valid ? dateDay()\n        : dateCount === valid ? timestamp()\n        : stringCount === valid ? dictionary(utf8())\n        : arrayCount === valid ? arrayType(arrayProfile.type(), minLength, maxLength)\n        : structCount === valid ? struct(\n            Object.entries(structProfiles).map(_ => field(_[0], _[1].type()))\n          )\n        : unionType();\n    }\n  };\n}\n\n/**\n * Return a list or fixed list type.\n * @param {DataType} type The child data type.\n * @param {number} minLength The minumum list length.\n * @param {number} maxLength The maximum list length.\n * @returns {DataType} The data type.\n */\nfunction arrayType(type, minLength, maxLength) {\n  return maxLength === minLength\n    ? fixedSizeList(type, minLength)\n    : list(type);\n}\n\n/**\n * @param {number} min\n * @param {number} max\n * @returns {DataType}\n */\nfunction intType(min, max) {\n  const v = Math.max(Math.abs(min) - 1, max);\n  return v < (1 << 7) ? int8()\n    : v < (1 << 15) ? int16()\n    : v < (2 ** 31) ? int32()\n    : float64();\n}\n\n/**\n * @param {bigint} min\n * @param {bigint} max\n * @returns {IntType}\n */\nfunction bigintType(min, max) {\n  const v = -min > max ? -min - 1n : max;\n  if (v >= 2 ** 63) {\n    throw new Error(`BigInt exceeds 64 bits: ${v}`);\n  }\n  return int64();\n}\n\n/**\n * @returns {UnionType}\n */\nfunction unionType() {\n  throw new Error('Mixed types detected, please define a union type.');\n}\n","import { toOffset } from '../../util/numbers.js';\nimport { buffer } from '../buffer.js';\nimport { ValidityBuilder } from './validity.js';\n\n/**\n * Builder for batches of binary-typed data.\n */\nexport class BinaryBuilder extends ValidityBuilder {\n  constructor(type, ctx) {\n    super(type, ctx);\n    this.toOffset = toOffset(type.offsets);\n  }\n\n  init() {\n    this.offsets = buffer(this.type.offsets);\n    this.values = buffer();\n    this.pos = 0;\n    return super.init();\n  }\n\n  set(value, index) {\n    const { offsets, values, toOffset } = this;\n    if (super.set(value, index)) {\n      values.write(value, this.pos);\n      this.pos += value.length;\n    }\n    offsets.set(toOffset(this.pos), index + 1);\n  }\n\n  done() {\n    return {\n      ...super.done(),\n      offsets: this.offsets.array(this.index + 2),\n      values: this.values.array(this.pos + 1)\n    };\n  }\n}\n","import { bitmap } from '../buffer.js';\nimport { ValidityBuilder } from './validity.js';\n\n/**\n * Builder for batches of bool-typed data.\n */\nexport class BoolBuilder extends ValidityBuilder {\n  constructor(type, ctx) {\n    super(type, ctx);\n  }\n\n  init() {\n    this.values = bitmap();\n    return super.init();\n  }\n\n  set(value, index) {\n    super.set(value, index);\n    if (value) this.values.set(index);\n  }\n\n  done() {\n    return {\n      ...super.done(),\n      values: this.values.array((this.index >> 3) + 1)\n    }\n  }\n}\n","import { toDecimal } from '../../util/numbers.js';\nimport { buffer } from '../buffer.js';\nimport { ValidityBuilder } from './validity.js';\n\n/**\n * Builder for batches of decimal-typed data (64-bits or more).\n */\nexport class DecimalBuilder extends ValidityBuilder {\n  constructor(type, ctx) {\n    super(type, ctx);\n    this.scale = 10 ** type.scale;\n    this.stride = type.bitWidth >> 6;\n  }\n\n  init() {\n    this.values = buffer(this.type.values);\n    return super.init();\n  }\n\n  set(value, index) {\n    const { scale, stride, values } = this;\n    if (super.set(value, index)) {\n      values.prep((index + 1) * stride);\n      // @ts-ignore\n      toDecimal(value, values.buf, index * stride, stride, scale);\n    }\n  }\n\n  done() {\n    const { index, stride, values } = this;\n    return {\n      ...super.done(),\n      values: values.array((index + 1) * stride)\n    };\n  }\n}\n","import { buffer } from '../buffer.js';\nimport { ValidityBuilder } from './validity.js';\n\n/**\n * Builder for fixed-size-binary-typed data batches.\n */\nexport class FixedSizeBinaryBuilder extends ValidityBuilder {\n  constructor(type, ctx) {\n    super(type, ctx);\n    this.stride = type.stride;\n  }\n\n  init() {\n    this.values = buffer();\n    return super.init();\n  }\n\n  set(value, index) {\n    if (super.set(value, index)) {\n      this.values.write(value, index * this.stride);\n    }\n  }\n\n  done() {\n    const { stride, values } = this;\n    return {\n      ...super.done(),\n      values: values.array(stride * (this.index + 1))\n    };\n  }\n}\n","import { ValidityBuilder } from './validity.js';\n\n/**\n * Builder for fixed-size-list-typed data batches.\n */\nexport class FixedSizeListBuilder extends ValidityBuilder {\n  constructor(type, ctx) {\n    super(type, ctx);\n    this.child = ctx.builder(this.type.children[0].type);\n    this.stride = type.stride;\n  }\n\n  init() {\n    this.child.init();\n    return super.init();\n  }\n\n  set(value, index) {\n    const { child, stride } = this;\n    const base = index * stride;\n    if (super.set(value, index)) {\n      for (let i = 0; i < stride; ++i) {\n        child.set(value[i], base + i);\n      }\n    } else {\n      child.index = base + stride;\n    }\n  }\n\n  done() {\n    const { child } = this;\n    return {\n      ...super.done(),\n      children: [ child.batch() ]\n    };\n  }\n}\n","import { toMonthDayNanoBytes } from '../../util/numbers.js';\nimport { buffer } from '../buffer.js';\nimport { ValidityBuilder } from './validity.js';\n\n/**\n * Builder for day/time interval-typed data batches.\n */\nexport class IntervalDayTimeBuilder extends ValidityBuilder {\n  init() {\n    this.values = buffer(this.type.values);\n    return super.init();\n  }\n\n  set(value, index) {\n    if (super.set(value, index)) {\n      const i = index << 1;\n      this.values.set(value[0], i);\n      this.values.set(value[1], i + 1);\n    }\n  }\n\n  done() {\n    return {\n      ...super.done(),\n      values: this.values.array((this.index + 1) << 1)\n    }\n  }\n}\n\n/**\n * Builder for month/day/nano interval-typed data batches.\n */\nexport class IntervalMonthDayNanoBuilder extends ValidityBuilder {\n  init() {\n    this.values = buffer();\n    return super.init();\n  }\n\n  set(value, index) {\n    if (super.set(value, index)) {\n      this.values.write(toMonthDayNanoBytes(value), index << 4);\n    }\n  }\n\n  done() {\n    return {\n      ...super.done(),\n      values: this.values.array((this.index + 1) << 4)\n    }\n  }\n}\n","import { toOffset } from '../../util/numbers.js';\nimport { buffer } from '../buffer.js';\nimport { ValidityBuilder } from './validity.js';\n\n/**\n * Abstract class for building list data batches.\n */\nexport class AbstractListBuilder extends ValidityBuilder {\n  constructor(type, ctx, child) {\n    super(type, ctx);\n    this.child = child;\n  }\n\n  init() {\n    this.child.init();\n    const offsetType = this.type.offsets;\n    this.offsets = buffer(offsetType);\n    this.toOffset = toOffset(offsetType);\n    this.pos = 0;\n    return super.init();\n  }\n\n  done() {\n    return {\n      ...super.done(),\n      offsets: this.offsets.array(this.index + 2),\n      children: [ this.child.batch() ]\n    };\n  }\n}\n\n/**\n * Builder for list-typed data batches.\n */\nexport class ListBuilder extends AbstractListBuilder {\n  constructor(type, ctx) {\n    super(type, ctx, ctx.builder(type.children[0].type));\n  }\n\n  set(value, index) {\n    const { child, offsets, toOffset } = this;\n    if (super.set(value, index)) {\n      value.forEach(v => child.set(v, this.pos++));\n    }\n    offsets.set(toOffset(this.pos), index + 1);\n  }\n}\n","import { ValidityBuilder } from './validity.js';\n\n/**\n * Abstract class for building list-typed data batches.\n */\nexport class AbstractStructBuilder extends ValidityBuilder {\n  constructor(type, ctx) {\n    super(type, ctx);\n    this.children = type.children.map(c => ctx.builder(c.type));\n  }\n\n  init() {\n    this.children.forEach(c => c.init());\n    return super.init();\n  }\n\n  done() {\n    const { children } = this;\n    children.forEach(c => c.index = this.index);\n    return {\n      ...super.done(),\n      children: children.map(c => c.batch())\n    };\n  }\n}\n\n/**\n * Builder for struct-typed data batches.\n */\nexport class StructBuilder extends AbstractStructBuilder {\n  constructor(type, ctx) {\n    super(type, ctx);\n    this.setters = this.children.map((child, i) => {\n      const name = type.children[i].name;\n      return (value, index) => child.set(value?.[name], index);\n    });\n  }\n\n  set(value, index) {\n    super.set(value, index);\n    const setters = this.setters;\n    for (let i = 0; i < setters.length; ++i) {\n      setters[i](value, index);\n    }\n  }\n}\n","import { AbstractListBuilder } from './list.js';\nimport { AbstractStructBuilder } from './struct.js';\n\n/**\n * Builder for map-typed data batches.\n */\nexport class MapBuilder extends AbstractListBuilder {\n  constructor(type, ctx) {\n    super(type, ctx, new MapStructBuilder(type.children[0].type, ctx));\n  }\n\n  set(value, index) {\n    const { child, offsets, toOffset } = this;\n    if (super.set(value, index)) {\n      for (const keyValuePair of value) {\n        child.set(keyValuePair, this.pos++);\n      }\n    }\n    offsets.set(toOffset(this.pos), index + 1);\n  }\n}\n\n/**\n * Builder for key-value struct batches within a map.\n */\nclass MapStructBuilder extends AbstractStructBuilder {\n  set(value, index) {\n    super.set(value, index);\n    const [key, val] = this.children;\n    key.set(value[0], index);\n    val.set(value[1], index);\n  }\n}\n","import { keyString } from '../../util/strings.js';\nimport { BatchBuilder } from './batch.js';\n\nconst NO_VALUE = {}; // empty object that fails strict equality\n\n/**\n * Builder for run-end-encoded-typed data batches.\n */\nexport class RunEndEncodedBuilder extends BatchBuilder {\n  constructor(type, ctx) {\n    super(type, ctx);\n    this.children = type.children.map(c => ctx.builder(c.type));\n  }\n\n  init() {\n    this.pos = 0;\n    this.key = null;\n    this.value = NO_VALUE;\n    this.children.forEach(c => c.init());\n    return super.init();\n  }\n\n  next() {\n    const [runs, vals] = this.children;\n    runs.set(this.index + 1, this.pos);\n    vals.set(this.value, this.pos++);\n  }\n\n  set(value, index) {\n    // perform fast strict equality test\n    if (value !== this.value) {\n      // if no match, fallback to key string test\n      const key = keyString(value);\n      if (key !== this.key) {\n        // if key doesn't match, write prior run and update\n        if (this.key) this.next();\n        this.key = key;\n        this.value = value;\n      }\n    }\n    this.index = index;\n  }\n\n  done() {\n    this.next();\n    const { children, index, type } = this;\n    return {\n      length: index + 1,\n      nullCount: 0,\n      type,\n      children: children.map(c => c.batch())\n    };\n  }\n}\n","import { int8Array } from '../../util/arrays.js';\nimport { BatchBuilder } from './batch.js';\nimport { buffer } from '../buffer.js';\n\n/**\n * Abstract class for building union-typed data batches.\n */\nexport class AbstractUnionBuilder extends BatchBuilder {\n  constructor(type, ctx) {\n    super(type, ctx);\n    this.children = type.children.map(c => ctx.builder(c.type));\n    this.typeMap = type.typeMap;\n    this.lookup = type.typeIdForValue;\n  }\n\n  init() {\n    this.nullCount = 0;\n    this.typeIds = buffer(int8Array);\n    this.children.forEach(c => c.init());\n    return super.init();\n  }\n\n  set(value, index) {\n    const { children, lookup, typeMap, typeIds } = this;\n    this.index = index;\n    const typeId = lookup(value, index);\n    const child = children[typeMap[typeId]];\n    typeIds.set(typeId, index);\n    if (value == null) ++this.nullCount;\n    // @ts-ignore\n    this.update(value, index, child);\n  }\n\n  done() {\n    const { children, nullCount, type, typeIds } = this;\n    const length = this.index + 1;\n    return {\n      length,\n      nullCount,\n      type,\n      typeIds: typeIds.array(length),\n      children: children.map(c => c.batch())\n    };\n  }\n}\n\n/**\n * Builder for sparse union-typed data batches.\n */\nexport class SparseUnionBuilder extends AbstractUnionBuilder {\n  update(value, index, child) {\n    // update selected child with value\n    // then set all other children to null\n    child.set(value, index);\n    this.children.forEach(c => { if (c !== child) c.set(null, index) });\n  }\n}\n\n/**\n * Builder for dense union-typed data batches.\n */\nexport class DenseUnionBuilder extends AbstractUnionBuilder {\n  init() {\n    this.offsets = buffer(this.type.offsets);\n    return super.init();\n  }\n\n  update(value, index, child) {\n    const offset = child.index + 1;\n    child.set(value, offset);\n    this.offsets.set(offset, index);\n  }\n\n  done() {\n    return {\n      ...super.done(),\n      offsets: this.offsets.array(this.index + 1)\n    };\n  }\n}\n","import { encodeUtf8 } from '../../util/strings.js';\nimport { BinaryBuilder } from './binary.js';\n\n/**\n * Builder for utf8-typed data batches.\n */\nexport class Utf8Builder extends BinaryBuilder {\n  set(value, index) {\n    super.set(value && encodeUtf8(value), index);\n  }\n}\n","import { toBigInt } from '../../util/numbers.js';\nimport { buffer } from '../buffer.js';\nimport { ValidityBuilder } from './validity.js';\n\n/**\n * Builder for data batches that can be accessed directly as typed arrays.\n */\nexport class DirectBuilder extends ValidityBuilder {\n  constructor(type, ctx) {\n    super(type, ctx);\n    this.values = buffer(type.values);\n  }\n\n  init() {\n    this.values = buffer(this.type.values);\n    return super.init();\n  }\n\n  /**\n   * @param {*} value\n   * @param {number} index\n   * @returns {boolean | void}\n   */\n  set(value, index) {\n    if (super.set(value, index)) {\n      this.values.set(value, index);\n    }\n  }\n\n  done() {\n    return {\n      ...super.done(),\n      values: this.values.array(this.index + 1)\n    };\n  }\n}\n\n/**\n * Builder for int64/uint64 data batches written as bigints.\n */\nexport class Int64Builder extends DirectBuilder {\n  set(value, index) {\n    super.set(value == null ? value : toBigInt(value), index);\n  }\n}\n\n/**\n * Builder for data batches whose values must pass through a transform\n * function prior to be written to a backing buffer.\n */\nexport class TransformBuilder extends DirectBuilder {\n  constructor(type, ctx, transform) {\n    super(type, ctx);\n    this.transform = transform;\n  }\n  set(value, index) {\n    super.set(value == null ? value : this.transform(value), index);\n  }\n}\n","/**\n * @import { DataType, ExtractionOptions } from '../types.js'\n * @import { BatchBuilder } from './builders/batch.js'\n */\nimport { batchType } from '../batch-type.js';\nimport { IntervalUnit, Type } from '../constants.js';\nimport { invalidDataType } from '../data-types.js';\nimport { isInt64ArrayType } from '../util/arrays.js';\nimport { toBigInt, toDateDay, toDecimal32, toFloat16, toTimestamp } from '../util/numbers.js';\nimport { BinaryBuilder } from './builders/binary.js';\nimport { BoolBuilder } from './builders/bool.js';\nimport { DecimalBuilder } from './builders/decimal.js';\nimport { DictionaryBuilder, dictionaryContext } from './builders/dictionary.js';\nimport { FixedSizeBinaryBuilder } from './builders/fixed-size-binary.js';\nimport { FixedSizeListBuilder } from './builders/fixed-size-list.js';\nimport { IntervalDayTimeBuilder, IntervalMonthDayNanoBuilder } from './builders/interval.js';\nimport { ListBuilder } from './builders/list.js';\nimport { MapBuilder } from './builders/map.js';\nimport { RunEndEncodedBuilder } from './builders/run-end-encoded.js';\nimport { StructBuilder } from './builders/struct.js';\nimport { DenseUnionBuilder, SparseUnionBuilder } from './builders/union.js';\nimport { Utf8Builder } from './builders/utf8.js';\nimport { DirectBuilder, Int64Builder, TransformBuilder } from './builders/values.js';\n\n/**\n * Create a context object for shared builder state.\n * @param {ExtractionOptions} [options]  Batch extraction options.\n* @param {ReturnType<dictionaryContext>} [dictionaries]\n *  Context object for tracking dictionaries.\n */\nexport function builderContext(\n  options = {},\n  dictionaries = dictionaryContext()\n) {\n  return {\n    batchType: type => batchType(type, options),\n    builder(type) { return builder(type, this); },\n    dictionary(type) { return dictionaries.get(type, this); },\n    finish: () => dictionaries.finish(options)\n  };\n}\n\n/**\n * Returns a batch builder for the given type and builder context.\n * @param {DataType} type A data type.\n * @param {ReturnType<builderContext>} [ctx] A builder context.\n * @returns {BatchBuilder}\n */\nexport function builder(type, ctx = builderContext()) {\n  const { typeId } = type;\n  switch (typeId) {\n    case Type.Int:\n    case Type.Time:\n    case Type.Duration:\n      return isInt64ArrayType(type.values)\n        ? new Int64Builder(type, ctx)\n        : new DirectBuilder(type, ctx);\n    case Type.Float:\n      return type.precision\n        ? new DirectBuilder(type, ctx)\n        : new TransformBuilder(type, ctx, toFloat16)\n    case Type.Binary:\n    case Type.LargeBinary:\n      return new BinaryBuilder(type, ctx);\n    case Type.Utf8:\n    case Type.LargeUtf8:\n      return new Utf8Builder(type, ctx);\n    case Type.Bool:\n      return new BoolBuilder(type, ctx);\n    case Type.Decimal:\n      return type.bitWidth === 32\n        ? new TransformBuilder(type, ctx, toDecimal32(type.scale))\n        : new DecimalBuilder(type, ctx);\n    case Type.Date:\n      return new TransformBuilder(type, ctx, type.unit ? toBigInt : toDateDay);\n    case Type.Timestamp:\n      return new TransformBuilder(type, ctx, toTimestamp(type.unit));\n    case Type.Interval:\n      switch (type.unit) {\n        case IntervalUnit.DAY_TIME:\n          return new IntervalDayTimeBuilder(type, ctx);\n        case IntervalUnit.MONTH_DAY_NANO:\n          return new IntervalMonthDayNanoBuilder(type, ctx);\n      }\n      // case IntervalUnit.YEAR_MONTH:\n      return new DirectBuilder(type, ctx);\n    case Type.List:\n    case Type.LargeList:\n      return new ListBuilder(type, ctx);\n    case Type.Struct:\n      return new StructBuilder(type, ctx);\n    case Type.Union:\n      return type.mode\n        ? new DenseUnionBuilder(type, ctx)\n        : new SparseUnionBuilder(type, ctx);\n    case Type.FixedSizeBinary:\n      return new FixedSizeBinaryBuilder(type, ctx);\n    case Type.FixedSizeList:\n      return new FixedSizeListBuilder(type, ctx);\n    case Type.Map:\n      return new MapBuilder(type, ctx);\n    case Type.RunEndEncoded:\n      return new RunEndEncodedBuilder(type, ctx);\n\n    case Type.Dictionary:\n      return new DictionaryBuilder(type, ctx);\n  }\n  // case Type.BinaryView:\n  // case Type.Utf8View:\n  // case Type.ListView:\n  // case Type.LargeListView:\n  throw new Error(invalidDataType(typeId));\n}\n","/**\n * @import { ColumnBuilderOptions, DataType, NullType } from '../types.js'\n * @import { dictionaryContext } from './builders/dictionary.js'\n */\nimport { NullBatch } from '../batch.js';\nimport { Column } from '../column.js';\nimport { inferType } from './infer-type.js';\nimport { builder, builderContext } from './builder.js';\nimport { Type } from '../constants.js';\nimport { isIterable } from '../util/objects.js';\n\n/**\n * Create a new column by iterating over provided values.\n * @template T\n * @param {Iterable | ((callback: (value: any) => void) => void)} values\n *  Either an iterable object or a visitor function that applies a callback\n *  to successive data values (akin to Array.forEach).\n * @param {DataType} [type] The data type.\n * @param {ColumnBuilderOptions} [options]\n *  Builder options for the generated column.\n * @param {ReturnType<dictionaryContext>} [dicts]\n *  Dictionary context object, for internal use only.\n * @returns {Column<T>} The generated column.\n */\nexport function columnFromValues(values, type, options = {}, dicts) {\n  const visit = isIterable(values)\n    ? callback => { for (const value of values) callback(value); }\n    : values;\n\n  type ??= inferType(visit);\n  const { maxBatchRows = Infinity, ...opt } = options;\n  let data;\n\n  if (type.typeId === Type.Null) {\n    let length = 0;\n    visit(() => ++length);\n    data = nullBatches(type, length, maxBatchRows);\n  } else {\n    const ctx = builderContext(opt, dicts);\n    const b = builder(type, ctx).init();\n    const next = b => data.push(b.batch());\n    data = [];\n\n    let row = 0;\n    visit(value => {\n      b.set(value, row++);\n      if (row >= maxBatchRows) {\n        next(b);\n        row = 0;\n      }\n    });\n    if (row) next(b);\n\n    // resolve dictionaries\n    ctx.finish();\n  }\n\n  return new Column(data, type);\n}\n\n/**\n * Create null batches with the given batch size limit.\n * @param {NullType} type The null data type.\n * @param {number} length The total column length.\n * @param {number} limit The maximum batch size.\n * @returns {NullBatch[]} The null batches.\n */\nfunction nullBatches(type, length, limit) {\n  const data = [];\n  const batch = length => new NullBatch({ length, nullCount: length, type });\n  const numBatches = Math.floor(length / limit);\n  for (let i = 0; i < numBatches; ++i) {\n    data.push(batch(limit));\n  }\n  const rem = length % limit;\n  if (rem) data.push(batch(rem));\n  return data;\n}\n","/**\n * @import { ColumnBuilderOptions, DataType, TypedArray, TypedArrayConstructor } from '../types.js'\n * @import { dictionaryContext } from './builders/dictionary.js'\n */\nimport { float32Array, float64Array, int16Array, int32Array, int64Array, int8Array, isInt64ArrayType, isTypedArray, uint16Array, uint32Array, uint64Array, uint8Array } from '../util/arrays.js';\nimport { DirectBatch, Int64Batch } from '../batch.js';\nimport { Column } from '../column.js';\nimport { float32, float64, int16, int32, int64, int8, uint16, uint32, uint64, uint8 } from '../data-types.js';\nimport { columnFromValues } from './column-from-values.js';\n\n/**\n * Create a new column from a provided data array.\n * @template T\n * @param {Array | TypedArray} array The input data.\n * @param {DataType} [type] The data type.\n *  If not specified, type inference is attempted.\n * @param {ColumnBuilderOptions} [options]\n *  Builder options for the generated column.\n * @param {ReturnType<dictionaryContext>} [dicts]\n *  Builder context object, for internal use only.\n * @returns {Column<T>} The generated column.\n */\nexport function columnFromArray(array, type, options = {}, dicts) {\n  return !type && isTypedArray(array)\n    ? columnFromTypedArray(array, options)\n    : columnFromValues(v => array.forEach(v), type, options, dicts);\n}\n\n/**\n * Create a new column from a typed array input.\n * @template T\n * @param {TypedArray} values The input data.\n * @param {ColumnBuilderOptions} options\n *  Builder options for the generated column.\n * @returns {Column<T>} The generated column.\n */\nfunction columnFromTypedArray(values, { maxBatchRows, useBigInt }) {\n  const arrayType = /** @type {TypedArrayConstructor} */ (\n    values.constructor\n  );\n  const type = typeForTypedArray(arrayType);\n  const length = values.length;\n  const limit = Math.min(maxBatchRows || Infinity, length);\n  const numBatches = Math.floor(length / limit);\n\n  const batches = [];\n  const batchType = isInt64ArrayType(arrayType) && !useBigInt ? Int64Batch : DirectBatch;\n  const add = (start, end) => batches.push(new batchType({\n    length: end - start,\n    nullCount: 0,\n    type,\n    validity: new uint8Array(0),\n    values: values.subarray(start, end)\n  }));\n\n  let idx = 0;\n  for (let i = 0; i < numBatches; ++i) add(idx, idx += limit);\n  if (idx < length) add(idx, length);\n\n  return new Column(batches);\n}\n\n/**\n * Return an Arrow data type for a given typed array type.\n * @param {TypedArrayConstructor} arrayType The typed array type.\n * @returns {DataType} The data type.\n */\nfunction typeForTypedArray(arrayType) {\n  switch (arrayType) {\n    case float32Array: return float32();\n    case float64Array: return float64();\n    case int8Array: return int8();\n    case int16Array: return int16();\n    case int32Array: return int32();\n    case int64Array: return int64();\n    case uint8Array: return uint8();\n    case uint16Array: return uint16();\n    case uint32Array: return uint32();\n    case uint64Array: return uint64();\n  }\n}\n","/**\n * @import { Column } from '../column.js'\n */\nimport { Endianness, Version } from '../constants.js';\nimport { field } from '../data-types.js';\nimport { Table } from '../table.js';\n\n/**\n * Create a new table from a collection of columns. Columns are assumed\n * to have the same record batch sizes.\n * @param {[string, Column][] | Record<string, Column>} data The columns,\n *  as an object with name keys, or an array of [name, column] pairs.\n * @param {boolean} [useProxy] Flag indicating if row proxy\n *  objects should be used to represent table rows (default `false`).\n * @returns {Table} The new table.\n */\nexport function tableFromColumns(data, useProxy) {\n  const fields = [];\n  const entries = Array.isArray(data) ? data : Object.entries(data);\n  const length = entries[0]?.[1].length;\n\n  const columns = entries.map(([name, col]) => {\n    if (col.length !== length) {\n      throw new Error('All columns must have the same length.');\n    }\n    fields.push(field(name, col.type));\n    return col;\n  });\n\n  const schema = {\n    version: Version.V5,\n    endianness: Endianness.Little,\n    fields,\n    metadata: null\n  };\n\n  return new Table(schema, columns, useProxy);\n}\n","/**\n * @import { Column } from '../column.js'\n * @import { TableBuilderOptions, TypedArray } from '../types.js'\n * @import { Table } from '../table.js'\n */\nimport { dictionaryContext } from './builders/dictionary.js';\nimport { columnFromArray } from './column-from-array.js';\nimport { tableFromColumns } from './table-from-columns.js';\n\n/**\n * Create a new table from the provided arrays.\n * @param {[string, Array | TypedArray][]\n *  | Record<string, Array | TypedArray>} data\n *  The input data as a collection of named arrays.\n * @param {TableBuilderOptions} options\n *  Table builder options, including an optional type map.\n * @returns {Table} The new table.\n */\nexport function tableFromArrays(data, options = {}) {\n  const { types = {}, ...opt } = options;\n  const dicts = dictionaryContext();\n  const entries = Array.isArray(data) ? data : Object.entries(data);\n  const columns = entries.map(([name, array]) =>\n    /** @type {[string, Column]} */ (\n    [ name, columnFromArray(array, types[name], opt, dicts)]\n  ));\n  return tableFromColumns(columns, options.useProxy);\n}\n"],"names":["MAGIC","Uint8Array","of","EOS","Version","V1","V2","V3","V4","V5","Endianness","Little","Big","MessageHeader","NONE","Schema","DictionaryBatch","RecordBatch","Tensor","SparseTensor","Type","Dictionary","Null","Int","Float","Binary","Utf8","Bool","Decimal","Date","Time","Timestamp","Interval","List","Struct","Union","FixedSizeBinary","FixedSizeList","Map","Duration","LargeBinary","LargeUtf8","LargeList","RunEndEncoded","BinaryView","Utf8View","ListView","LargeListView","Precision","HALF","SINGLE","DOUBLE","DateUnit","DAY","MILLISECOND","TimeUnit","SECOND","MICROSECOND","NANOSECOND","IntervalUnit","YEAR_MONTH","DAY_TIME","MONTH_DAY_NANO","UnionMode","Sparse","Dense","CompressionType","LZ4_FRAME","ZSTD","BodyCompressionMethod","uint8Array","uint16Array","Uint16Array","uint32Array","Uint32Array","uint64Array","BigUint64Array","int8Array","Int8Array","int16Array","Int16Array","int32Array","Int32Array","int64Array","BigInt64Array","float32Array","Float32Array","float64Array","Float64Array","intArrayType","bitWidth","signed","i","Math","log2","TypedArray","Object","getPrototypeOf","isTypedArray","value","isArray","Array","isInt64ArrayType","bisect","offsets","index","a","b","length","mid","trunc","resize","array","newLength","offset","newArray","constructor","set","grow","shift","check","test","message","Error","checkOneOf","values","includes","keyFor","object","key","val","entries","invalidDataType","typeId","field","name","type","nullable","metadata","isField","hasOwn","isDataType","asField","defaultName","defaultNullable","basicType","dictionary","indexType","ordered","id","indices","int32","nullType","int","int8","int16","int64","uint8","uint16","uint32","uint64","float","precision","float32","float64","binary","utf8","bool","decimal","scale","date","unit","dateDay","time","timestamp","timezone","interval","undefined","list","child","children","struct","map","union","mode","typeIds","typeIdForValue","v","typeMap","reduce","m","fixedSizeBinary","stride","fixedSizeList","mapType","keysSorted","duration","largeBinary","largeUtf8","largeList","runEndEncoded","runsField","valuesField","listView","largeListView","f64","buf","buffer","i64","u32","i32","u8","identity","toBigInt","BigInt","toOffset","toDateDay","toNumber","Number","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","divide","num","div","asUint64","asUintN","fromDecimal64","asIntN","fromDecimal128","x","fromDecimal256","toFloat16","sign","expo","sigf","textDecoder","TextDecoder","textEncoder","TextEncoder","decodeUtf8","decode","encodeUtf8","str","encode","keyString","isDate","s","k","objectKey","decodeBit","bitmap","readObject","pos","readInt32","vtable","size","readInt16","read","fallback","off","readOffset","readBoolean","readInt8","readUint8","readUint16","readUint32","readInt64","readString","subarray","readVector","extract","base","from","_","RowIndex","Symbol","proxyFactory","names","batches","RowObject","this","toJSON","structObject","proto","prototype","batch","defineProperty","get","at","enumerable","objectFactory","obj","Batch","static","nullCount","validity","sizes","toStringTag","isValid","slice","start","end","n","iterator","DirectBatch","options","super","NumberBatch","ArrayBatch","NullBatch","Int64Batch","Float16Batch","NaN","BoolBatch","Decimal32NumberBatch","DecimalBatch","DecimalNumberBatch","DecimalBigIntBatch","DateBatch","source","DateDayBatch","DateDayMillisecondBatch","TimestampSecondBatch","TimestampMillisecondBatch","TimestampMicrosecondBatch","TimestampNanosecondBatch","IntervalDayTimeBatch","IntervalMonthDayNanoBatch","offset32","offset64","BinaryBatch","LargeBinaryBatch","Utf8Batch","LargeUtf8Batch","ListBatch","LargeListBatch","ListViewBatch","LargeListViewBatch","FixedBatch","FixedBinaryBatch","FixedListBatch","pairs","keys","vals","push","MapEntryBatch","MapBatch","SparseUnionBatch","DenseUnionBatch","StructBatch","factory","StructProxyBatch","RunEndEncodedBatch","runs","setDictionary","cache","ViewBatch","data","view","BinaryViewBatch","Utf8ViewBatch","columnBuilder","add","clear","done","Column","c","iter","next","batchedIterator","toArray","copy","ArrayType","copyArray","j","extractArray","_cache","Table","schema","useProxy","fields","f","gen","getFactory","numCols","numRows","getChildAt","getChild","findIndex","selectAt","as","renameField","select","all","indexOf","toColumns","cols","forEach","output","row","batchType","useBigInt","useDate","useDecimalInt","useMap","wrap","BaseClass","WrapperClass","writeInt32","writeInt64","INIT_SIZE","Builder","sink","minalign","space","vtables","outputBytes","writeInt8","writeInt16","addInt8","prep","addInt16","addInt32","addInt64","addOffset","addObject","numFields","addFields","builder","fill","startOffset","slot","defaultValue","finish","vtableOffset","standardFields","len","existingTable","vt1","outer_loop","vt2","objectBuilder","addVector","items","itemSize","alignment","writeItem","addOffsetVector","addString","rootOffset","flush","bytes","write","byteLength","addBuffer","pad","addPadding","byteCount","additionalBytes","bufSize","used","alignSize","missingCodec","codecs","getCompressionCodec","decodeBlock","metadataLength","bodyLength","decodeBlocks","decodeBodyCompression","codec","method","decodeRecordBatch","version","nodes","regions","compression","variadic","decodeDictionaryBatch","isDelta","decodeDataType","decodeMetadata","decodeSchema","endianness","decodeSchemaFields","fieldsOffset","decodeField","typeOffset","dict","decodeDictionary","decodeFieldChildren","fieldOffset","decodeInt","decodeMessage","head","expected","actual","content","decoder","invalidMessageType","body","invalidMessageBodyLength","decodeIPC","ArrayBuffer","SharedArrayBuffer","isArrayBufferLike","isArrowFileFormat","dicts","recs","dictionaries","records","decodeIPCFile","stream","flat","decodeIPCStream","visit","ctx","node","BatchType","encodeRecordBatch","nodeVector","regionVector","region","variadicVector","count","encodeCompression","encodeDictionaryBatch","dictionaryBatch","dataOffset","encodeMetadata","encodeDataType","encodeDictionary","encodeInt","encodeFloat","encodeDecimal","encodeDate","encodeTime","timezoneOffset","encodeTimestamp","encodeInterval","encodeDuration","encodeFixedSize","encodeMap","typeIdsOffset","encodeUnion","isLittleEndian","encodeSchema","fieldOffsets","encodeField","fieldsVectorOffset","metadataOffset","dictionaryOffset","childOffsets","childrenVectorOffset","nameOffset","encodeBlock","writeMessage","headerType","headerOffset","blocks","messageSize","alignedSize","Sink","MemorySink","buffers","bufs","sum","STREAM","FILE","encodeIPC","format","file","dictBlocks","recordBlocks","writeBuffers","recsOffset","dictsOffset","schemaOffset","writeFooter","assembleContext","byteOffset","compressed","keep","compressBuffer","visitDictionaries","visitor","assembleRecordBatch","columns","batchIndex","column","arrayType","Buffer","alignedLength","bpe","align64","BYTES_PER_ELEMENT","align","Bitmap","BatchBuilder","batchClass","init","ValidityBuilder","dictionaryContext","idMap","Set","has","create","dictionaryValues","DictionaryBuilder","inferType","profile","profiler","minBigInt","maxBigInt","arrayProfile","boolCount","numberCount","intCount","bigintCount","dateCount","dayCount","stringCount","arrayCount","structCount","min","Infinity","max","minLength","maxLength","structProfiles","isInteger","valid","abs","intType","bigintType","unionType","BinaryBuilder","BoolBuilder","DecimalBuilder","toDecimal","FixedSizeBinaryBuilder","FixedSizeListBuilder","IntervalDayTimeBuilder","IntervalMonthDayNanoBuilder","d","toMonthDayNanoBytes","AbstractListBuilder","offsetType","ListBuilder","AbstractStructBuilder","StructBuilder","setters","MapBuilder","MapStructBuilder","keyValuePair","NO_VALUE","RunEndEncodedBuilder","AbstractUnionBuilder","lookup","update","SparseUnionBuilder","DenseUnionBuilder","Utf8Builder","DirectBuilder","Int64Builder","TransformBuilder","transform","builderContext","columnFromValues","callback","maxBatchRows","opt","limit","numBatches","floor","rem","nullBatches","columnFromArray","typeForTypedArray","idx","columnFromTypedArray","tableFromColumns","col","keyField","valueField","types","dictionaryMap","context","nodeIndex","bufferIndex","variadicIndex","ulen","decompressBuffer","maybeDecompress","contextGenerator","dictionaryTypes","visitField","visitSchemaFields","createTable","table","some","checkBatchLengths","dictMap","dictionaryColumn","assembleDictionaryBatches","assembleRecordBatches","visitDictType","visitFields","parentType","assembleSchema"],"mappings":"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"}